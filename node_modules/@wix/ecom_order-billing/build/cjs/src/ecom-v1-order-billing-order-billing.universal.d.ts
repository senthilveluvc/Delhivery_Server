export interface OrderBilling {
    /** Entity ID. */
    _id?: string | null;
}
export interface GetOrderRefundabilityRequest {
    /** Order ID. */
    orderId: string;
}
export interface GetOrderRefundabilityResponse {
    /** Payments and their refundability amounts and statuses. */
    payments?: PaymentRefundability[];
    /** Aggregated payments summary. */
    paymentsSummary?: PaymentsSummary;
    /** List of line item refund quantities. */
    lineItems?: LineItemRefundability[];
    /** Shipping refund amounts - both previously refunded and the amount still available for refund. */
    shipping?: ShippingRefundability;
    /** List of additional fee refund amounts - both previously refunded and the amount still available for refund. */
    additionalFees?: AdditionalFeeRefundability[];
}
export interface PaymentRefundability extends PaymentRefundabilityStatusOneOf {
    /** Whether the payment is available for both automatic and manual refunds. */
    refundable?: boolean;
    /** Reason why the payment is only manually refundable. */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /** Reason why the payment is not refundable. */
    nonRefundable?: NonRefundablePaymentStatus;
    /** Payment details. */
    payment?: PaymentInfo;
    /** URL to the payment provider's dashboard. */
    providerLink?: string | null;
}
/** @oneof */
export interface PaymentRefundabilityStatusOneOf {
    /** Whether the payment is available for both automatic and manual refunds. */
    refundable?: boolean;
    /** Reason why the payment is only manually refundable. */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /** Reason why the payment is not refundable. */
    nonRefundable?: NonRefundablePaymentStatus;
}
export interface PaymentInfo extends PaymentInfoSummaryOneOf, PaymentInfoPaymentMethodDetailsOneOf {
    /** Monetary payment summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment summary. */
    membership?: MembershipPaymentSummary;
    /** Details of the credit card used for this payment. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /** Payment ID. */
    paymentId?: string;
    /**
     * Payment method. Non-exhaustive list of supported values:
     *
     * `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     */
    paymentMethod?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
}
/** @oneof */
export interface PaymentInfoSummaryOneOf {
    /** Monetary payment summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment summary. */
    membership?: MembershipPaymentSummary;
}
/** @oneof */
export interface PaymentInfoPaymentMethodDetailsOneOf {
    /** Details of the credit card used for this payment. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
export interface MonetaryPaymentSummary {
    /** Paid amount. */
    paid?: Price;
    /** Refunded amount. */
    refunded?: Price;
    /** Pending refund amount. */
    refundPending?: Price;
    /**
     * Maximum amount to refund,  **if** the refund is available.
     * max_refund = paid - refunded - refund_pending
     * `maxRefund` is calculated as `paid` minus `refunded` minus `refundPending`.
     */
    maxRefund?: Price;
}
export interface Price {
    /** Amount. */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
}
export interface MembershipPaymentSummary {
    /** IDs of line items paid with a membership. */
    paidLineItemIds?: string[];
    /** IDs of line items previously refunded, and paid with a membership. */
    refundedLineItemIds?: string[];
    /** IDs of line items paid with a membership and available for refund. */
    refundableLineItemIds?: string[];
}
export interface CreditCardPaymentMethodDetails {
    /** The last 4 digits of the card number. */
    lastFourDigits?: string | null;
    /** Card issuer's brand. */
    brand?: string | null;
}
export interface ManuallyRefundablePaymentStatus {
    /** Reason why the payment must be manually refunded via the payment provider's dashboard. */
    reason?: ManuallyRefundableReason;
}
export declare enum ManuallyRefundableReason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    EXPIRED = "EXPIRED",
    NOT_SUPPORTED = "NOT_SUPPORTED",
    OFFLINE = "OFFLINE",
    REQUIRES_CARD_READER = "REQUIRES_CARD_READER"
}
export interface NonRefundablePaymentStatus {
    /** Reason why the payment is not refundable. */
    reason?: NonRefundableReason;
}
export declare enum NonRefundableReason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    ALREADY_REFUNDED = "ALREADY_REFUNDED",
    PROVIDER_IS_DOWN = "PROVIDER_IS_DOWN",
    NOT_PAID = "NOT_PAID",
    ZERO_PRICE = "ZERO_PRICE",
    DISABLED_BY_PROVIDER = "DISABLED_BY_PROVIDER",
    PENDING_REFUND = "PENDING_REFUND",
    FORBIDDEN = "FORBIDDEN",
    TRANSACTION_NOT_FOUND = "TRANSACTION_NOT_FOUND",
    ORDER_IS_PENDING = "ORDER_IS_PENDING",
    ORDER_IS_REJECTED = "ORDER_IS_REJECTED"
}
export interface PaymentsSummary {
    /** Monetary payments summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payments summary. */
    membership?: MembershipPaymentSummary;
}
export interface LineItemRefundability {
    /** Line item ID. */
    lineItemId?: string;
    /** Original line item quantity before any refunds. */
    originalQuantity?: number;
    /** Previously refunded line item quantity. */
    refundedQuantity?: number;
    /** Line item quantity that is available for refund. */
    availableRefundQuantity?: number;
}
export interface ShippingRefundability {
    /** Original shipping fee amount. */
    amount?: Price;
    /** Previously refunded shipping fee amount. */
    refundedAmount?: Price;
    /** Shipping fee amount available for refund. */
    availableRefundAmount?: Price;
}
export interface AdditionalFeeRefundability {
    /** Additional fee ID. */
    additionalFeeId?: string;
    /** Original additional fee amount. */
    amount?: Price;
    /** Previously refunded additional fee amount. */
    refundedAmount?: Price;
    /** Additional fee amount available for refund. */
    availableRefundAmount?: Price;
}
export interface CalculateRefundRequest {
    /** Order ID. */
    orderId: string;
    /** List of line items, shipping and additional fees to be calculated for refund. */
    refundItems?: RefundItems;
}
export interface RefundItems {
    /** Line items and their quantities to refund. */
    lineItems?: LineItemRefund[];
    /** Additional fees and their amounts to refund. */
    additionalFees?: AdditionalFeeRefund[];
    /** Shipping amount to refund. */
    shipping?: ShippingRefund;
}
export interface LineItemRefund {
    /** Line item ID. */
    lineItemId?: string;
    /** Quantity to refund. */
    quantity?: number;
}
export interface AdditionalFeeRefund {
    /** Additional fee ID. */
    additionalFeeId?: string;
    /**
     * Amount to refund.
     *
     * Passing an empty value will refund the remaining refundable amount.
     */
    amount?: Price;
}
export interface ShippingRefund {
    /**
     * Amount to refund.
     *
     * Passing an empty value will refund the remaining refundable amount.
     */
    amount?: Price;
}
export interface CalculateRefundResponse extends CalculateRefundResponseStatusOneOf {
    /** Whether refund is available for the given list of items. */
    available?: boolean;
    /** If the calculated refund is not available, this field contains error details and amounts for each item. */
    notAvailable?: CalculatedRefundNotAvailableStatus;
    /**
     * Aggregated summary of all items provided for refund.
     *
     * This field is not returned when refund is not available for the given list of items.
     */
    summary?: AggregatedRefundSummary;
    /** Calculated summary of each item provided for refund. */
    calculatedRefundItems?: CalculatedRefundItems;
}
/** @oneof */
export interface CalculateRefundResponseStatusOneOf {
    /** Whether refund is available for the given list of items. */
    available?: boolean;
    /** If the calculated refund is not available, this field contains error details and amounts for each item. */
    notAvailable?: CalculatedRefundNotAvailableStatus;
}
export interface AggregatedRefundSummary {
    /** Total refund amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
    /** Total cost of the line items being refunded (without tax and discount). */
    lineItemsSubtotal?: Price;
    /** Total cost of the additional fees being refunded. */
    additionalFeesTotal?: Price;
}
export interface CalculatedRefundItems {
    /** Calculated refund details for each line item. */
    lineItems?: CalculatedLineItemRefund[];
    /** Calculated refund details for each additional fee. */
    additionalFees?: CalculatedAdditionalFeeRefund[];
    /** Calculated refund details for the shipping fee. */
    shipping?: CalculatedShippingRefund;
}
export interface CalculatedLineItemRefund {
    /** Line item refund details. */
    item?: LineItemRefund;
    /** Calculated refund summary for this line item. */
    summary?: CalculatedRefundSummary;
}
export interface CalculatedRefundSummary {
    /** Total refundable amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
}
export interface CalculatedAdditionalFeeRefund {
    /** Additional fee refund details. */
    additionalFee?: AdditionalFeeRefund;
    /** Calculated refund summary for this additional fee. */
    summary?: CalculatedRefundSummary;
}
export interface CalculatedShippingRefund {
    /** Shipping refund details. */
    shipping?: ShippingRefund;
    /** Calculated refund summary for shipping. */
    summary?: CalculatedRefundSummary;
}
export interface CalculatedRefundNotAvailableStatus {
    /** Refund calculation errors. */
    errors?: CalculationError[];
}
export interface CalculationError extends CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
    /** Error details */
    error?: Details;
}
/** @oneof */
export interface CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
}
export interface Details extends DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
    /**
     * deprecated in API's - to enable migration from rendering arbitrary tracing to rest response
     * @deprecated
     */
    tracing?: Record<string, string>;
}
/** @oneof */
export interface DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
}
export interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
/**
 * example result:
 * {
 * "fieldViolations": [
 * {
 * "field": "fieldA",
 * "description": "invalid music note. supported notes: [do,re,mi,fa,sol,la,ti]",
 * "violatedRule": "OTHER",
 * "ruleName": "INVALID_NOTE",
 * "data": {
 * "value": "FI"
 * }
 * },
 * {
 * "field": "fieldB",
 * "description": "field value out of range. supported range: [0-20]",
 * "violatedRule": "MAX",
 * "data": {
 * "threshold": 20
 * }
 * },
 * {
 * "field": "fieldC",
 * "description": "invalid phone number. provide a valid phone number of size: [7-12], supported characters: [0-9, +, -, (, )]",
 * "violatedRule": "FORMAT",
 * "data": {
 * "type": "PHONE"
 * }
 * }
 * ]
 * }
 */
export interface ValidationError {
    fieldViolations?: FieldViolation[];
}
export declare enum RuleType {
    VALIDATION = "VALIDATION",
    OTHER = "OTHER",
    MAX = "MAX",
    MIN = "MIN",
    MAX_LENGTH = "MAX_LENGTH",
    MIN_LENGTH = "MIN_LENGTH",
    MAX_SIZE = "MAX_SIZE",
    MIN_SIZE = "MIN_SIZE",
    FORMAT = "FORMAT",
    DECIMAL_LTE = "DECIMAL_LTE",
    DECIMAL_GTE = "DECIMAL_GTE",
    DECIMAL_LT = "DECIMAL_LT",
    DECIMAL_GT = "DECIMAL_GT",
    DECIMAL_MAX_SCALE = "DECIMAL_MAX_SCALE",
    INVALID_ENUM_VALUE = "INVALID_ENUM_VALUE",
    REQUIRED_FIELD = "REQUIRED_FIELD",
    FIELD_NOT_ALLOWED = "FIELD_NOT_ALLOWED",
    ONE_OF_ALIGNMENT = "ONE_OF_ALIGNMENT",
    EXACT_LENGTH = "EXACT_LENGTH",
    EXACT_SIZE = "EXACT_SIZE",
    REQUIRED_ONE_OF_FIELD = "REQUIRED_ONE_OF_FIELD"
}
export interface FieldViolation {
    field?: string;
    description?: string;
    violatedRule?: RuleType;
    /** applicable when violated_rule=OTHER */
    ruleName?: string | null;
    data?: Record<string, any> | null;
}
export interface SystemError {
    /** Error code. */
    errorCode?: string | null;
}
export interface RefundPaymentsRequest {
    /** Order ID. */
    orderId: string;
    /** List of payments and their amounts to refund. */
    paymentRefunds: PaymentRefund[];
    /** Side effect actions for restocking and notifications. */
    sideEffects?: RefundSideEffects;
    /** List of line items, shipping and additional fees to refund. */
    refundItems?: RefundItems;
    /** Customer-provided reason for the refund. */
    customerReason?: string | null;
}
export interface PaymentRefund {
    /** Specific payment within the order to refund */
    paymentId?: string;
    /** Refund amount. Not relevant for membership and gift card refunds. */
    amount?: Price;
    /**
     * Indicates that refund is made externally and manually (on the payment provider's side)
     * When false (default), the payment gateway will be called in order to make an actual refund, and then the payment will be marked as refunded.
     * When true, the payment will only be *marked* as refunded, and no actual refund will be performed.
     */
    externalRefund?: boolean;
}
export interface RefundSideEffects {
    /** Restocking side effects. */
    restock?: RestockSideEffects;
    /** Notification side effects. */
    notifications?: NotificationSideEffects;
}
export interface RestockItem {
    /** Line item ID. */
    lineItemId?: string;
    /** Quantity to restock. */
    quantity?: number;
}
export interface RestockSideEffects {
    /** List of items to restock. */
    lineItems?: RestockItem[];
}
export interface NotificationSideEffects {
    /**
     * Whether to send a refund confirmation email to the customer.
     *
     * Default: `false`
     */
    sendCustomerEmail?: boolean;
    /** Custom message added to the refund confirmation email. */
    customMessage?: string | null;
}
export interface RefundPaymentsResponse {
    /** Refund details. */
    refund?: Refund;
    /** The order's transactions records after the refunds were performed. */
    orderTransactions?: OrderTransactions;
}
export interface Refund {
    /**
     * Refund ID.
     * @readonly
     */
    _id?: string;
    /** List of transactions. */
    transactions?: RefundTransaction[];
    /** Refund business details. */
    details?: RefundDetails;
    /**
     * Date and time the refund was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     */
    _createdDate?: Date | null;
}
export interface RefundTransaction {
    /** ID of the payment associated with this refund. */
    paymentId?: string;
    /** Refund amount. */
    amount?: Price;
    /** Refund status. */
    refundStatus?: RefundStatus;
    /** Optional details of current refund status. */
    refundStatusInfo?: RefundStatusInfo;
    /**
     * Payment gateway's refund ID. This ID can be used with the Wix Payments [Transactions API](https://dev.wix.com/docs/rest/api-reference/wix-payments/transactions/introduction).
     * This field is only returned when the value of `external_refund` is `false`.
     */
    gatewayRefundId?: string | null;
    /** ID of the refund in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for external refunds. */
    providerRefundId?: string | null;
    /** Whether refund was made externally and manually on the payment provider's side. */
    externalRefund?: boolean;
}
/** Refund transaction status. */
export declare enum RefundStatus {
    /** Refund was initiated on payment provider side. PENDING status was assigned by provider. */
    PENDING = "PENDING",
    /** Refund transaction succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Refund transaction failed. */
    FAILED = "FAILED",
    /** Refund request acknowledged, and will be executed soon. */
    SCHEDULED = "SCHEDULED",
    /** Refund was initiated on payment provider side. */
    STARTED = "STARTED"
}
export interface RefundStatusInfo {
}
/** Business model of a refund request */
export interface RefundDetails {
    /** Order line item IDs and quantities that were refunded. */
    items?: RefundItem[];
    /** Whether the shipping fee was also refunded. */
    shippingIncluded?: boolean;
    /** Reason for the refund, provided by customer (optional). */
    reason?: string | null;
}
export interface RefundItem {
    /** Line item ID the refunded line item. */
    lineItemId?: string;
    /** Line item quantity refunded. */
    quantity?: number;
}
export interface V1LineItemRefund {
}
export interface V1AdditionalFeeRefund {
}
export interface V1ShippingRefund {
}
export interface V1AggregatedRefundSummary {
}
export interface OrderTransactions {
    /** Order ID. */
    orderId?: string;
    /** Record of payments made to the merchant. */
    payments?: Payment[];
    /** Record of refunds made to the buyer. */
    refunds?: Refund[];
}
export interface Payment extends PaymentPaymentDetailsOneOf, PaymentReceiptInfoOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
    /**
     * Payment ID.
     * @readonly
     */
    _id?: string | null;
    /** Date and time the payment was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided. */
    _createdDate?: Date | null;
    /**
     * Date and time the payment was last updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Payment amount. */
    amount?: Price;
    /**
     * Whether refunds for this payment are disabled.
     * + `true`: This payment is not refundable.
     * + `false`: This payment may be refunded. However, this ultimately depends on the payment provider.
     */
    refundDisabled?: boolean;
}
/** @oneof */
export interface PaymentPaymentDetailsOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
}
/** @oneof */
export interface PaymentReceiptInfoOneOf {
}
export interface RegularPaymentDetails extends RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /** Wix Payments order ID. */
    paymentOrderId?: string | null;
    /**
     * Payment gateway's transaction ID. This ID can be used with the Wix Payments [Transactions API](https://dev.wix.com/docs/rest/api-reference/wix-payments/transactions/introduction).
     * This field is only returned when the value of `offline_payment` is `false`.
     */
    gatewayTransactionId?: string | null;
    /**
     * Payment method. Non-exhaustive list of supported values:
     * + `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     */
    paymentMethod?: string | null;
    /** Transaction ID in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for offline payments. */
    providerTransactionId?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
    /** Payment status. */
    status?: TransactionStatus;
    /** Whether there is a payment agreement that allows for future charges. */
    savedPaymentMethod?: boolean;
    /** Authorization details. */
    authorizationDetails?: AuthorizationDetails;
}
/** @oneof */
export interface RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
export declare enum TransactionStatus {
    UNDEFINED = "UNDEFINED",
    APPROVED = "APPROVED",
    PENDING = "PENDING",
    PENDING_MERCHANT = "PENDING_MERCHANT",
    CANCELED = "CANCELED",
    DECLINED = "DECLINED",
    REFUNDED = "REFUNDED",
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    AUTHORIZED = "AUTHORIZED",
    VOIDED = "VOIDED"
}
export interface AuthorizationDetails {
    /**
     * Whether the authorized payment is of a delayed capture.
     * @readonly
     */
    delayedCapture?: boolean;
    /** Date and time the payment was authorized in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    authorizedDate?: Date | null;
    /**
     * List of captures associated with payment
     * In case of failed it can be replaced with new one with PENDING or SUCCESS statuses
     */
    captures?: AuthorizationCapture[];
    /** Void associated with payment */
    void?: AuthorizationVoid;
    /** Scheduled action for this transaction */
    scheduledAction?: V1ScheduledAction;
}
export interface AuthorizationCapture {
    /**
     * Capture ID.
     * @readonly
     */
    _id?: string | null;
    /** Status of this capture action */
    status?: AuthorizationCaptureStatus;
    /** Amount of this capture */
    amount?: Price;
    /** Date and time the capture was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    _createdDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
}
export declare enum AuthorizationCaptureStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Capture operation still in progress. */
    PENDING = "PENDING",
    /** Capture operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Capture operation failed. */
    FAILED = "FAILED"
}
export interface AuthorizationActionFailureDetails {
    failureCode?: string;
}
export interface AuthorizationVoid {
    /** Status of this void action */
    status?: AuthorizationVoidStatus;
    /** Date and time the void was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    voidedDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
    /** Reason of void action */
    reason?: Reason;
}
export declare enum AuthorizationVoidStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Void operation still in progress. */
    PENDING = "PENDING",
    /** Void operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Void operation failed. */
    FAILED = "FAILED"
}
/** Reason the authorization was voided. */
export declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** Authorization was voided by user. */
    MANUAL = "MANUAL",
    /** Authorization passed execution date. */
    SCHEDULED = "SCHEDULED"
}
export interface V1ScheduledAction {
    /** Type of the action. */
    actionType?: ActionType;
    /** The date and time of the action. */
    executionDate?: Date | null;
}
export declare enum ActionType {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    VOID = "VOID",
    CAPTURE = "CAPTURE"
}
export interface GiftCardPaymentDetails {
    /** Gift card payment ID. */
    giftCardPaymentId?: string;
    /** ID of the app that created the gift card. */
    appId?: string;
    /**
     * Whether the gift card is voided.
     * @readonly
     */
    voided?: boolean;
}
export interface MembershipPaymentDetails {
    /** Membership ID. */
    membershipId?: string;
    /** ID of the line item this membership applies to. */
    lineItemId?: string;
    /** Payment status. */
    status?: MembershipPaymentStatus;
    /** Membership name. */
    name?: MembershipName;
    /** The transaction ID in the membership system. Can be used to void the transaction. */
    externalTransactionId?: string | null;
    /**
     * Whether the membership is voided.
     * @readonly
     */
    voided?: boolean;
    /** ID of the application providing this payment option. */
    providerAppId?: string;
}
export declare enum MembershipPaymentStatus {
    /** Payment was charged. */
    CHARGED = "CHARGED",
    /** The attempt to charge the payment failed, for example, due to lack of credits. */
    CHARGE_FAILED = "CHARGE_FAILED"
}
export interface MembershipName {
    /** Membership name. */
    original?: string;
    /** Translated membership name. Defaults to `original` when not provided. */
    translated?: string | null;
}
export interface WixReceiptInfo {
    /** Receipt ID */
    receiptId?: string;
    /** Display number of receipt */
    displayNumber?: string | null;
}
export interface ExternalReceiptInfo {
    /** External receipt ID */
    receiptId?: string | null;
    /** ID of the app providing the receipt */
    appId?: string | null;
    /** Display number of receipt */
    displayNumber?: string | null;
}
export interface PaymentNotRefundableDetails {
    /** Payment ID. */
    paymentId?: string;
    /** Reason why payment is not refundable. */
    nonRefundableReason?: NonRefundableReason;
}
export interface AuthorizeChargeWithSavedPaymentMethodRequest {
    /**
     * Order ID.
     *
     * The order must have a saved payment method associated.
     * Pass the order ID to the List Transactions For Single Order method and search the response for a payment with `regularPaymentDetails.savedPaymentMethod: true`.
     * If no saved payment exists, the call will fail.
     */
    orderId: string;
    /** Amount to authorize. */
    amount: Price;
    /** Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format. */
    currency: string;
    /** Settings for scheduled action to perform automatically. */
    delayedCaptureSettings: DelayedCaptureSettings;
}
export interface DelayedCaptureSettings {
    /** The action to perform on the authorized payment after the specified duration. */
    scheduledAction?: ScheduledAction;
    /**
     * Delay duration before performing the scheduled action.
     * > **Note:** If not set, the payment provider's default period will be used.
     */
    delayDuration?: Duration;
}
export declare enum ScheduledAction {
    UNSPECIFIED = "UNSPECIFIED",
    /** Whether payment will be auto-voided when duration passes. */
    VOID = "VOID",
    /** Whether payment will be auto-captured when duration passes. */
    CAPTURE = "CAPTURE"
}
export interface Duration {
    /** Amount of units. For example, 30 MINUTES, 1 HOURS, 7 DAYS, etc */
    count?: number;
    /** Duration unit: MINUTES, HOURS and DAYS */
    unit?: DurationUnit;
}
export declare enum DurationUnit {
    UNKNOWN_DURATION_UNIT = "UNKNOWN_DURATION_UNIT",
    MINUTES = "MINUTES",
    HOURS = "HOURS",
    DAYS = "DAYS"
}
export interface AuthorizeChargeWithSavedPaymentMethodResponse {
    /** Authorized payment. */
    payment?: Payment;
    /** Order transactions updated with authorized payment. */
    orderTransactions?: OrderTransactions;
}
export interface VoidAuthorizedPaymentsRequest {
    /** Order ID. */
    orderId: string;
    /** IDs of the authorized payments to void. */
    paymentIds: string[];
}
export interface VoidAuthorizedPaymentsResponse {
    /** Order transactions updated with voided payment. */
    orderTransactions?: OrderTransactions;
}
export interface CaptureAuthorizedPaymentsRequest {
    /** Order ID. */
    orderId: string;
    /** List payment IDs and amounts to capture. */
    payments: PaymentCapture[];
}
export interface PaymentCapture {
    /** ID of the payment to capture. */
    paymentId?: string;
    /**
     * Capture amount.
     *
     * > **Note:** If not provided, the full authorized amount will be captured.
     */
    amount?: Price;
}
export interface CaptureAuthorizedPaymentsResponse {
    /** Order transactions updated with captured payment. */
    orderTransactions?: OrderTransactions;
}
export interface GenerateReceiptsRequest {
    /** Order ID. */
    orderId?: string;
    /** Payment IDs. */
    paymentIds?: string[];
}
export interface GenerateReceiptsResponse {
    /** Generated receipts information. */
    receipts?: ReceiptInfo[];
}
export interface ReceiptInfo {
    /** Payment ID. */
    paymentId?: string;
    /** Receipt ID. */
    receiptId?: string;
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entity?: string;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
export interface ActionEvent {
    body?: string;
}
export interface Empty {
}
interface ManuallyRefundablePaymentStatusNonNullableFields {
    reason: ManuallyRefundableReason;
}
interface NonRefundablePaymentStatusNonNullableFields {
    reason: NonRefundableReason;
}
interface PriceNonNullableFields {
    amount: string;
    formattedAmount: string;
}
interface MonetaryPaymentSummaryNonNullableFields {
    paid?: PriceNonNullableFields;
    refunded?: PriceNonNullableFields;
    refundPending?: PriceNonNullableFields;
    maxRefund?: PriceNonNullableFields;
}
interface MembershipPaymentSummaryNonNullableFields {
    paidLineItemIds: string[];
    refundedLineItemIds: string[];
    refundableLineItemIds: string[];
}
interface PaymentInfoNonNullableFields {
    monetary?: MonetaryPaymentSummaryNonNullableFields;
    membership?: MembershipPaymentSummaryNonNullableFields;
    paymentId: string;
    offlinePayment: boolean;
}
interface PaymentRefundabilityNonNullableFields {
    refundable: boolean;
    manuallyRefundable?: ManuallyRefundablePaymentStatusNonNullableFields;
    nonRefundable?: NonRefundablePaymentStatusNonNullableFields;
    payment?: PaymentInfoNonNullableFields;
}
interface PaymentsSummaryNonNullableFields {
    monetary?: MonetaryPaymentSummaryNonNullableFields;
    membership?: MembershipPaymentSummaryNonNullableFields;
}
interface LineItemRefundabilityNonNullableFields {
    lineItemId: string;
    originalQuantity: number;
    refundedQuantity: number;
    availableRefundQuantity: number;
}
interface ShippingRefundabilityNonNullableFields {
    amount?: PriceNonNullableFields;
    refundedAmount?: PriceNonNullableFields;
    availableRefundAmount?: PriceNonNullableFields;
}
interface AdditionalFeeRefundabilityNonNullableFields {
    additionalFeeId: string;
    amount?: PriceNonNullableFields;
    refundedAmount?: PriceNonNullableFields;
    availableRefundAmount?: PriceNonNullableFields;
}
export interface GetOrderRefundabilityResponseNonNullableFields {
    payments: PaymentRefundabilityNonNullableFields[];
    paymentsSummary?: PaymentsSummaryNonNullableFields;
    lineItems: LineItemRefundabilityNonNullableFields[];
    shipping?: ShippingRefundabilityNonNullableFields;
    additionalFees: AdditionalFeeRefundabilityNonNullableFields[];
}
interface LineItemRefundNonNullableFields {
    lineItemId: string;
    quantity: number;
}
interface AdditionalFeeRefundNonNullableFields {
    additionalFeeId: string;
    amount?: PriceNonNullableFields;
}
interface ShippingRefundNonNullableFields {
    amount?: PriceNonNullableFields;
}
interface ApplicationErrorNonNullableFields {
    code: string;
    description: string;
}
interface FieldViolationNonNullableFields {
    field: string;
    description: string;
    violatedRule: RuleType;
}
interface ValidationErrorNonNullableFields {
    fieldViolations: FieldViolationNonNullableFields[];
}
interface DetailsNonNullableFields {
    applicationError?: ApplicationErrorNonNullableFields;
    validationError?: ValidationErrorNonNullableFields;
}
interface CalculationErrorNonNullableFields {
    lineItem?: LineItemRefundNonNullableFields;
    additionalFee?: AdditionalFeeRefundNonNullableFields;
    shipping?: ShippingRefundNonNullableFields;
    error?: DetailsNonNullableFields;
}
interface CalculatedRefundNotAvailableStatusNonNullableFields {
    errors: CalculationErrorNonNullableFields[];
}
interface AggregatedRefundSummaryNonNullableFields {
    total?: PriceNonNullableFields;
    tax?: PriceNonNullableFields;
    discount?: PriceNonNullableFields;
    subtotal?: PriceNonNullableFields;
    lineItemsSubtotal?: PriceNonNullableFields;
    additionalFeesTotal?: PriceNonNullableFields;
}
interface CalculatedRefundSummaryNonNullableFields {
    total?: PriceNonNullableFields;
    tax?: PriceNonNullableFields;
    discount?: PriceNonNullableFields;
    subtotal?: PriceNonNullableFields;
}
interface CalculatedLineItemRefundNonNullableFields {
    item?: LineItemRefundNonNullableFields;
    summary?: CalculatedRefundSummaryNonNullableFields;
}
interface CalculatedAdditionalFeeRefundNonNullableFields {
    additionalFee?: AdditionalFeeRefundNonNullableFields;
    summary?: CalculatedRefundSummaryNonNullableFields;
}
interface CalculatedShippingRefundNonNullableFields {
    shipping?: ShippingRefundNonNullableFields;
    summary?: CalculatedRefundSummaryNonNullableFields;
}
interface CalculatedRefundItemsNonNullableFields {
    lineItems: CalculatedLineItemRefundNonNullableFields[];
    additionalFees: CalculatedAdditionalFeeRefundNonNullableFields[];
    shipping?: CalculatedShippingRefundNonNullableFields;
}
export interface CalculateRefundResponseNonNullableFields {
    available: boolean;
    notAvailable?: CalculatedRefundNotAvailableStatusNonNullableFields;
    summary?: AggregatedRefundSummaryNonNullableFields;
    calculatedRefundItems?: CalculatedRefundItemsNonNullableFields;
}
interface RefundTransactionNonNullableFields {
    paymentId: string;
    amount?: PriceNonNullableFields;
    refundStatus: RefundStatus;
    externalRefund: boolean;
}
interface RefundItemNonNullableFields {
    lineItemId: string;
    quantity: number;
}
interface V1LineItemRefundNonNullableFields {
    lineItemId: string;
    quantity: number;
}
interface V1AdditionalFeeRefundNonNullableFields {
    additionalFeeId: string;
    amount?: PriceNonNullableFields;
}
interface V1ShippingRefundNonNullableFields {
    amount?: PriceNonNullableFields;
}
interface RefundDetailsNonNullableFields {
    items: RefundItemNonNullableFields[];
    shippingIncluded: boolean;
    lineItems: V1LineItemRefundNonNullableFields[];
    additionalFees: V1AdditionalFeeRefundNonNullableFields[];
    shipping?: V1ShippingRefundNonNullableFields;
}
interface V1AggregatedRefundSummaryNonNullableFields {
    requestedRefund?: PriceNonNullableFields;
    pendingRefund?: PriceNonNullableFields;
    refunded?: PriceNonNullableFields;
    failedRefundAmount?: PriceNonNullableFields;
    pending: boolean;
}
interface RefundNonNullableFields {
    _id: string;
    transactions: RefundTransactionNonNullableFields[];
    details?: RefundDetailsNonNullableFields;
    summary?: V1AggregatedRefundSummaryNonNullableFields;
}
interface AuthorizationActionFailureDetailsNonNullableFields {
    failureCode: string;
}
interface AuthorizationCaptureNonNullableFields {
    status: AuthorizationCaptureStatus;
    amount?: PriceNonNullableFields;
    failureDetails?: AuthorizationActionFailureDetailsNonNullableFields;
}
interface AuthorizationVoidNonNullableFields {
    status: AuthorizationVoidStatus;
    failureDetails?: AuthorizationActionFailureDetailsNonNullableFields;
    reason: Reason;
}
interface V1ScheduledActionNonNullableFields {
    actionType: ActionType;
}
interface AuthorizationDetailsNonNullableFields {
    delayedCapture: boolean;
    captures: AuthorizationCaptureNonNullableFields[];
    void?: AuthorizationVoidNonNullableFields;
    scheduledAction?: V1ScheduledActionNonNullableFields;
}
interface RegularPaymentDetailsNonNullableFields {
    offlinePayment: boolean;
    status: TransactionStatus;
    savedPaymentMethod: boolean;
    authorizationDetails?: AuthorizationDetailsNonNullableFields;
}
interface GiftCardPaymentDetailsNonNullableFields {
    giftCardPaymentId: string;
    giftCardId: string;
    appId: string;
    voided: boolean;
}
interface MembershipNameNonNullableFields {
    original: string;
}
interface MembershipPaymentDetailsNonNullableFields {
    membershipId: string;
    lineItemId: string;
    status: MembershipPaymentStatus;
    name?: MembershipNameNonNullableFields;
    voided: boolean;
    providerAppId: string;
}
interface WixReceiptInfoNonNullableFields {
    receiptId: string;
}
interface PaymentNonNullableFields {
    regularPaymentDetails?: RegularPaymentDetailsNonNullableFields;
    giftcardPaymentDetails?: GiftCardPaymentDetailsNonNullableFields;
    membershipPaymentDetails?: MembershipPaymentDetailsNonNullableFields;
    wixReceipt?: WixReceiptInfoNonNullableFields;
    amount?: PriceNonNullableFields;
    refundDisabled: boolean;
    supportReceiptGeneration: boolean;
}
interface OrderTransactionsNonNullableFields {
    orderId: string;
    payments: PaymentNonNullableFields[];
    refunds: RefundNonNullableFields[];
}
export interface RefundPaymentsResponseNonNullableFields {
    refund?: RefundNonNullableFields;
    orderTransactions?: OrderTransactionsNonNullableFields;
}
export interface AuthorizeChargeWithSavedPaymentMethodResponseNonNullableFields {
    payment?: PaymentNonNullableFields;
    orderTransactions?: OrderTransactionsNonNullableFields;
}
export interface VoidAuthorizedPaymentsResponseNonNullableFields {
    orderTransactions?: OrderTransactionsNonNullableFields;
}
export interface CaptureAuthorizedPaymentsResponseNonNullableFields {
    orderTransactions?: OrderTransactionsNonNullableFields;
}
/**
 * Retrieves refund information about an order's payments, line items, shipping, and additional fees.
 *
 * The following information is returned:
 * - Whether a payment is refundable; previously refunded amounts; possible refund amounts for each payment.
 * - Refundable and previously refunded quantities for each line item, as well as shipping and additional fees.
 * @param orderId - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_GET_ORDER_REFUNDABILITY
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.GetOrderRefundability
 */
export declare function getOrderRefundability(orderId: string): Promise<GetOrderRefundabilityResponse & GetOrderRefundabilityResponseNonNullableFields>;
/**
 * Calculates refund amounts for a given list of an order's line items, shipping, and additional fees.
 * @param orderId - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField options.refundItems.additionalFees.additionalFeeId
 * @requiredField options.refundItems.lineItems.lineItemId
 * @requiredField options.refundItems.lineItems.quantity
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_CALCULATE_REFUND
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.CalculateRefund
 */
export declare function calculateRefund(orderId: string, options?: CalculateRefundOptions): Promise<CalculateRefundResponse & CalculateRefundResponseNonNullableFields>;
export interface CalculateRefundOptions {
    /** List of line items, shipping and additional fees to be calculated for refund. */
    refundItems?: RefundItems;
}
/**
 * Calls relevant payment providers and creates refund transactions for the requested payments.
 *
 * Refunds marked with `paymentRefunds.externalRefund = true` do not call payment providers and
 * only update the order's transactions records.
 * @param orderId - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField options.paymentRefunds
 * @requiredField options.paymentRefunds.paymentId
 * @requiredField options.refundItems.additionalFees.additionalFeeId
 * @requiredField options.refundItems.lineItems.lineItemId
 * @requiredField options.refundItems.lineItems.quantity
 * @requiredField options.sideEffects.restock.lineItems.lineItemId
 * @requiredField options.sideEffects.restock.lineItems.quantity
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_REFUND_PAYMENTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.RefundPayments
 */
export declare function refundPayments(orderId: string, options?: RefundPaymentsOptions): Promise<RefundPaymentsResponse & RefundPaymentsResponseNonNullableFields>;
export interface RefundPaymentsOptions {
    /** List of payments and their amounts to refund. */
    paymentRefunds: PaymentRefund[];
    /** Side effect actions for restocking and notifications. */
    sideEffects?: RefundSideEffects;
    /** List of line items, shipping and additional fees to refund. */
    refundItems?: RefundItems;
    /** Customer-provided reason for the refund. */
    customerReason?: string | null;
}
/**
 * Authorizes a payment using an order's saved payment method.
 *
 * Use the `delayedCaptureSettings` field to specify whether the payment should also be captured/voided immediately or at a later time.
 * Alternatively, the payment can be manually captured or voided using the Capture Authorized Payments or Void Authorized Payments methods.
 * @param orderId - Order ID.
 *
 * The order must have a saved payment method associated.
 * Pass the order ID to the List Transactions For Single Order method and search the response for a payment with `regularPaymentDetails.savedPaymentMethod: true`.
 * If no saved payment exists, the call will fail.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.amount
 * @requiredField options.amount.amount
 * @requiredField options.currency
 * @requiredField options.delayedCaptureSettings
 * @requiredField options.delayedCaptureSettings.scheduledAction
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_AUTHORIZE_CHARGE_WITH_SAVED_PAYMENT_METHOD
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.AuthorizeChargeWithSavedPaymentMethod
 */
export declare function authorizeChargeWithSavedPaymentMethod(orderId: string, options: AuthorizeChargeWithSavedPaymentMethodOptions): Promise<AuthorizeChargeWithSavedPaymentMethodResponse & AuthorizeChargeWithSavedPaymentMethodResponseNonNullableFields>;
export interface AuthorizeChargeWithSavedPaymentMethodOptions {
    /** Amount to authorize. */
    amount: Price;
    /** Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format. */
    currency: string;
    /** Settings for scheduled action to perform automatically. */
    delayedCaptureSettings: DelayedCaptureSettings;
}
/**
 * Voids an order's authorized payments.
 * @param orderId - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.paymentIds
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_VOID_AUTHORIZED_PAYMENTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.VoidAuthorizedPayments
 */
export declare function voidAuthorizedPayments(orderId: string, options: VoidAuthorizedPaymentsOptions): Promise<VoidAuthorizedPaymentsResponse & VoidAuthorizedPaymentsResponseNonNullableFields>;
export interface VoidAuthorizedPaymentsOptions {
    /** IDs of the authorized payments to void. */
    paymentIds: string[];
}
/**
 * Captures an order's authorized payments.
 * @param orderId - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.payments
 * @requiredField options.payments.paymentId
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_CAPTURE_AUTHORIZED_PAYMENTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.CaptureAuthorizedPayments
 */
export declare function captureAuthorizedPayments(orderId: string, options: CaptureAuthorizedPaymentsOptions): Promise<CaptureAuthorizedPaymentsResponse & CaptureAuthorizedPaymentsResponseNonNullableFields>;
export interface CaptureAuthorizedPaymentsOptions {
    /** List payment IDs and amounts to capture. */
    payments: PaymentCapture[];
}
export {};
