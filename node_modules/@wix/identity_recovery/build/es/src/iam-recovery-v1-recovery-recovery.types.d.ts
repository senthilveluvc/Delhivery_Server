/** Recovery token proto is the saved data on the recovery token. */
export interface RecoveryToken {
    /**
     * Recovery token ID
     * @readonly
     */
    id?: string | null;
    /**
     * Represents the time this SessionToken was created
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * tenantId
     * @readonly
     */
    tenantId?: string;
    /**
     * TenantType
     * @readonly
     */
    tenantType?: TenantType;
    /**
     * identity id
     * @readonly
     */
    identityId?: string;
}
export declare enum TenantType {
    UNKNOWN_TENANT_TYPE = "UNKNOWN_TENANT_TYPE",
    ACCOUNT = "ACCOUNT",
    SITE = "SITE",
    ROOT = "ROOT"
}
export interface SendRecoveryEmailRequest {
    /** Email address associated with the account to recover. */
    email: string;
    /**
     * 2-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format of the email to be sent.
     *
     * If no language is specified, the language specified in the member's profile is used.
     */
    language?: string | null;
    /** Where to redirect to after successfully resetting the password. */
    redirect?: Redirect;
}
export interface Redirect {
    /** URL to redirect to after successfully resetting the password. */
    url?: string;
    /** Client ID of the [OAuth app](https://dev.wix.com/docs/go-headless/getting-started/setup/authentication/create-an-oauth-app-for-visitors-and-members) your Headless project is using. */
    clientId?: string | null;
}
export interface SendRecoveryEmailResponse {
}
export interface SendActivationEmailRequest {
    /** Id of the activating user */
    identityId: string;
    /** Options for the activation email */
    emailOptions?: EmailOptions;
}
export interface EmailOptions {
    /** language of the email - if not received will fallback to the identity language */
    language?: string | null;
    /** Where to redirect after a successful activation process */
    redirect?: Redirect;
}
export interface SendActivationEmailResponse {
}
export interface RecoverRequest {
    /** recovery token */
    recoveryToken: string;
    /** new password to set for the identity */
    password?: string | null;
}
export interface StateMachineResponse extends StateMachineResponseStateDataOneOf {
    /** Current state of the login or registration process. */
    state?: StateType;
    /** Session token. If `state` is not `SUCCESS`, this field is undefined. */
    sessionToken?: string | null;
    /** Token that represents the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identity of the current member. */
    identity?: Identity;
    /** Additional data relevant to the login or registration process. */
    additionalData?: Record<string, CustomValue>;
}
/** @oneof */
export interface StateMachineResponseStateDataOneOf {
}
export declare enum StateType {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** Login completed successfully. */
    SUCCESS = "SUCCESS",
    /** Indicates that the member needs the owner to approve their registration. */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /** Indicates that the member needs to verify their email. */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** Indicates that the `status` is not one that prevents the member logging in, meaning it's not `OFFLINE`, `BLOCKED`, or `DELETED`. */
    STATUS_CHECK = "STATUS_CHECK"
}
export interface Identity {
    /** Identity ID. */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the identity is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the identity.
     *
     * Ignored when creating an identity.
     */
    revision?: string | null;
    /**
     * Date and time the identity was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the identity was updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection[];
    /** Identity profile. */
    identityProfile?: IdentityProfile;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata;
    /** Identity email address. */
    email?: Email;
    /** Identity's current status. */
    status?: StatusV2;
    /** Custom attributes. */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity verification factors.
     * @readonly
     */
    factors?: Factor[];
}
export interface Connection extends ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
/** @oneof */
export interface ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
export interface IdpConnection {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
export interface AuthenticatorConnection {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
export interface IdentityProfile {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail[];
    /** List of profile phone numbers. */
    phonesV2?: Phone[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate in `YYYY-MM-DD` format. */
    birthdate?: string | null;
    /** Profile slug. */
    slug?: string | null;
}
export declare enum PrivacyStatus {
    /** No defined privacy status. */
    UNDEFINED = "UNDEFINED",
    /** Profile details, such as profile name and profile picture, are visible to other members. */
    PUBLIC = "PUBLIC",
    /** Profile details aren't visible to other members. */
    PRIVATE = "PRIVATE"
}
export interface CustomField {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue;
}
export interface V1CustomValue extends V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
/** @oneof */
export interface V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
export interface V1ListValue {
    /** Custom value. */
    value?: V1CustomValue[];
}
export interface V1MapValue {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue>;
}
export interface SecondaryEmail {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag;
}
export declare enum EmailTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
export interface Phone {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag;
}
export declare enum PhoneTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
export interface AddressWrapper {
    /** Address. */
    address?: Address;
    /** Address tag. */
    tag?: AddressTag;
}
/** Physical address */
export interface Address {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
    /** Free text providing more detailed address info. Usually contains apartment, suite, and floor. */
    addressLine2?: string | null;
}
export declare enum AddressTag {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
export interface Metadata {
    /**
     * General tags. For example, `"isOwner"`.
     * @readonly
     */
    tags?: string[];
}
export interface Email {
    /** Email address. */
    address?: string;
    /** Whether the email address is verified. */
    isVerified?: boolean;
}
export interface StatusV2 {
    name?: StatusName;
    reasons?: Reason[];
}
export declare enum StatusName {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
export declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
export interface Factor {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType;
    /** Factor status. */
    status?: Status;
}
export declare enum FactorType {
    /** Unknown factor type. */
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    /** Requires a password. */
    PASSWORD = "PASSWORD",
    /** Requires a code sent via SMS. */
    SMS = "SMS",
    /** Requires a code sent by phone call. */
    CALL = "CALL",
    /** Requires a code sent by email. */
    EMAIL = "EMAIL",
    /** Requires authentication via an authenticator app. */
    TOTP = "TOTP",
    /** Requires authentication via a push notification. */
    PUSH = "PUSH"
}
export declare enum Status {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
export interface CustomValue extends CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
/** @oneof */
export interface CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
export interface ListValue {
    /** Custom value. */
    value?: CustomValue[];
}
export interface MapValue {
    /** Mapped custom value. */
    value?: Record<string, CustomValue>;
}
export interface RequireMfaData {
    availableFactors?: V1Factor[];
}
export interface V1Factor {
    /** Type of verifation factor. */
    factorType?: FactorType;
}
export interface MfaChallengeData {
    /** Type of verifation factor. */
    factorType?: FactorType;
    verificationChallengeData?: VerificationChallenge;
    /** Factors types the member can choose from to verify themselves. */
    availableFactors?: V1Factor[];
}
export interface VerificationChallenge extends VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
    hint?: string | null;
}
/** @oneof */
export interface VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
}
export interface PushChallengeData {
    /**
     * This should be tied to a specific push notification.
     * It will be sent in subsequent requests to verify the factor.
     */
    transactionId?: string;
}
interface V1FactorNonNullableFields {
    factorType: FactorType;
}
interface RequireMfaDataNonNullableFields {
    availableFactors: V1FactorNonNullableFields[];
}
interface PushChallengeDataNonNullableFields {
    transactionId: string;
}
interface VerificationChallengeNonNullableFields {
    pushData?: PushChallengeDataNonNullableFields;
}
interface MfaChallengeDataNonNullableFields {
    factorType: FactorType;
    verificationChallengeData?: VerificationChallengeNonNullableFields;
    availableFactors: V1FactorNonNullableFields[];
}
interface IdpConnectionNonNullableFields {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields {
    idpConnection?: IdpConnectionNonNullableFields;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields;
}
interface V1ListValueNonNullableFields {
    value: V1CustomValueNonNullableFields[];
}
interface V1CustomValueNonNullableFields {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields;
}
interface CustomFieldNonNullableFields {
    name: string;
    value?: V1CustomValueNonNullableFields;
}
interface SecondaryEmailNonNullableFields {
    email: string;
    tag: EmailTag;
}
interface PhoneNonNullableFields {
    phone: string;
    tag: PhoneTag;
}
interface AddressWrapperNonNullableFields {
    tag: AddressTag;
}
interface IdentityProfileNonNullableFields {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus;
    customFields: CustomFieldNonNullableFields[];
    secondaryEmails: SecondaryEmailNonNullableFields[];
    phonesV2: PhoneNonNullableFields[];
    addresses: AddressWrapperNonNullableFields[];
}
interface MetadataNonNullableFields {
    tags: string[];
}
interface EmailNonNullableFields {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields {
    name: StatusName;
    reasons: Reason[];
}
interface FactorNonNullableFields {
    factorId: string;
    type: FactorType;
    status: Status;
}
interface IdentityNonNullableFields {
    connections: ConnectionNonNullableFields[];
    identityProfile?: IdentityProfileNonNullableFields;
    metadata?: MetadataNonNullableFields;
    email?: EmailNonNullableFields;
    status?: StatusV2NonNullableFields;
    factors: FactorNonNullableFields[];
}
export interface StateMachineResponseNonNullableFields {
    requireMfaData?: RequireMfaDataNonNullableFields;
    mfaChallengeData?: MfaChallengeDataNonNullableFields;
    state: StateType;
    identity?: IdentityNonNullableFields;
}
export {};
