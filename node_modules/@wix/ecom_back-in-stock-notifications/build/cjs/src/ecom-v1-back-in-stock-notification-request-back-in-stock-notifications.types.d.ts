/**
 * The back in stock notification request allows a customer to receive a notifiction when a specific item
 * is available again. The request includes information about the person making the request, the item
 * they want to receive a notification for, and the status of the notification.
 */
export interface BackInStockNotificationRequest {
    /**
     * Request ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Catalog and item reference that the notification request is for.
     *
     * Includes IDs for the catalog and item it came from, as well as additional, optional information.
     */
    catalogReference?: CatalogReference;
    /** Email address to send notification to about item being back in stock. */
    email?: string;
    /**
     * Contact ID for the contact with this `email`.
     *
     * If a contact does not already exist with the email address submitted when creating this request, then a new contact is created.
     * For more information about contacts, see the [Contacts API](https://dev.wix.com/docs/rest/api-reference/contacts/introduction).
     * @readonly
     */
    contactId?: string | null;
    /**
     * Status of the notification.
     *
     * `status` is set to `RECEIVED` when the notification request is created.
     * The `status` changes once a notification email is sent for this request object:
     * + When a notification email is sent through the site, either automatically or with [Report Items Back In Stock](/report-items-back-in-stock), then the `status` is briefly set to `PROCESSING` and then set to `NOTIFICATION_SENT` if the email is successul, and `FAILED` if it fails.
     * + When a notification email is sent offline, use [Mark As Notification Sent](/mark-as-notification-sent) to set `status` to `NOTIFICATION_SENT`.
     * @readonly
     */
    status?: Status;
    /**
     * Whether a notification was sent automatically.
     *
     * `autoNotified` is empty when the notification request is created and is not returned until
     * the field has a value. `autoNotified` receives a value when a notification email is sent for this request object.
     *
     * `autoNotified` sets to `TRUE` if the notification is sent through the site, either automatically or with [Report Items Back In Stock](/report-items-back-in-stock).
     * If the notification email is sent offline but the `status` is updated with [Mark As Notification Sent](/mark-as-notification-sent),
     * then `autoNotified` sets to `FALSE`.
     * @readonly
     */
    autoNotified?: boolean | null;
    /**
     * Date and time the notification request was created.
     * @readonly
     */
    createdDate?: Date | null;
    /** Item URL for this request. */
    itemUrl?: string | null;
}
/** Used for grouping line items. Sent when an item is added to a cart, checkout, or order. */
export interface CatalogReference {
    /** ID of the item within the catalog it belongs to. */
    catalogItemId?: string;
    /**
     * ID of the app providing the catalog.
     *
     * You can get your app's ID from its page in the [app dashboard](https://dev.wix.com/dc3/my-apps/).
     *
     * For items from Wix catalogs, the following values always apply:
     * + Wix Stores: `"215238eb-22a5-4c36-9e7b-e7c08025e04e"`
     * + Wix Bookings: `"13d21c63-b5ec-5912-8397-c3a5ddb27a97"`
     * + Wix Restaurants: `"9a5d83fd-8570-482e-81ab-cfa88942ee60"`
     */
    appId?: string;
    /**
     * Additional item details in key:value pairs. Use this optional field to provide more specificity with item selection. The `options` field values differ depending on which catalog is providing the items.
     *
     * For products and variants from a Wix Stores catalog, learn more about [eCommerce integration](https://dev.wix.com/docs/rest/business-solutions/stores/catalog/e-commerce-integration).
     */
    options?: Record<string, any> | null;
}
export declare enum Status {
    UNSPECIFIED = "UNSPECIFIED",
    /** initial status of all new requests */
    RECEIVED = "RECEIVED",
    PROCESSING = "PROCESSING",
    NOTIFICATION_SENT = "NOTIFICATION_SENT",
    FAILED = "FAILED"
}
export interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** tell us why you're invalidating the cache. You don't need to add your app name */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
export interface InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
}
export interface App {
    /** The AppDefId */
    appDefId?: string;
    /** The instance Id */
    instanceId?: string;
}
export interface Page {
    /** the msid the page is on */
    metaSiteId?: string;
    /** Invalidate by Page ID */
    pageId?: string;
}
export interface URI {
    /** the msid the URI is on */
    metaSiteId?: string;
    /** URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes */
    uriPath?: string;
}
export interface File {
    /** the msid the file is related to */
    metaSiteId?: string;
    /** Invalidate by filename (for media files such as PDFs) */
    fileName?: string;
}
export interface CreateBackInStockNotificationRequestRequest {
    /**
     * Notification request information.
     *
     * Includes details for the out of stock item and the email address
     * requesting to be notified when it's back in stock.
     */
    request: BackInStockNotificationRequest;
    /** Item details to include in the notification when the item is back in stock. */
    itemDetails: BackInStockItemDetails;
}
export interface BackInStockItemDetails {
    /** Item name. */
    name?: string;
    /** Item price. */
    price?: string;
    /** Item image. */
    image?: Image;
}
export interface Image {
    /** WixMedia image ID. */
    id?: string;
    /** Image URL. */
    url?: string;
    /**
     * Original image height.
     * @readonly
     */
    height?: number;
    /**
     * Original image width.
     * @readonly
     */
    width?: number;
    /** Image alt text. */
    altText?: string | null;
    /**
     * Image filename.
     * @readonly
     */
    filename?: string | null;
}
export interface CreateBackInStockNotificationRequestResponse {
    /** Created back in stock notification request. */
    request?: BackInStockNotificationRequest;
}
export interface GetBackInStockNotificationRequestRequest {
    /** ID of the notification request to retrieve. */
    id: string;
}
export interface GetBackInStockNotificationRequestResponse {
    /** Retrieved back in stock notification request. */
    request?: BackInStockNotificationRequest;
}
export interface DeleteBackInStockNotificationRequestRequest {
    /** ID of the notification request to delete. */
    id: string;
}
export interface DeleteBackInStockNotificationRequestResponse {
}
export interface MarkAsNotificationSentRequest {
    /** ID of the notification request to mark. */
    id: string;
}
export interface MarkAsNotificationSentResponse {
    /** Marked back in stock notification request. */
    request?: BackInStockNotificationRequest;
}
export interface QueryBackInStockNotificationRequestsRequest {
    /** Query options. */
    query: PlatformQuery;
}
export interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting[];
}
/** @oneof */
export interface PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
export interface PlatformPaging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
export interface QueryBackInStockNotificationRequestsResponse {
    /** Retrieved back in stock requests. */
    requests?: BackInStockNotificationRequest[];
    /** Details on the paged set of results returned. */
    metadata?: PlatformPagingMetadata;
}
export interface PlatformPagingMetadata {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors;
}
export interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
export interface GetBackInStockNotificationRequestsCountByCatalogReferencesRequest {
    /** `catalogReference` items to retrieve the notification request for. */
    catalogReferences: CatalogReference[];
}
export interface GetBackInStockNotificationRequestsCountByCatalogReferencesResponse {
    /** Amount of back in stock notifications for each of the retrieved `catalogReference` items. */
    countsPerCatalogReference?: BackInStockNotificationRequestsCount[];
}
/** Maps each back in stock CatalogReference to the results (the number of unique occurrences). */
export interface BackInStockNotificationRequestsCount {
    /**
     * Catalog and item reference.
     *
     * Includes IDs and additional, optional information related to the item.
     */
    catalogReference?: CatalogReference;
    /** The number of unique back in stock requests for given `catalogReference`. */
    count?: number;
}
export interface ReportItemsBackInStockRequest {
    /**
     * `catalogReference` item to send notifications for.
     *
     * Cannot be used with `requestIds`.
     */
    catalogReference?: CatalogReference;
    /**
     * IDs of requests to send notifications for.
     *
     * Cannot be used with `catalogReference`.
     */
    requestIds?: string[];
    /**
     * Item details to use in notifications.
     *
     * `itemDetails` may populate dynamic valyes in the notification template, as follows:
     * + `itemDetails.name` passes to the template as `item.name`
     * + `itemDetails.price` passes to the template as `item.price`
     * + `itemDetails.image.url` passes to the template as `item.image.url`
     *
     * Use `extraAutomationTemplateParameters` to pass additional dynamic values.
     */
    itemDetails: BackInStockItemDetails;
    /** Additional key-value pairs to pass to the back in stock notification template. */
    extraAutomationTemplateParameters?: Record<string, string>;
}
export interface ReportItemsBackInStockResponse {
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntityAsJson?: string | null;
}
export interface ActionEvent {
    bodyAsJson?: string;
}
export interface Empty {
}
export interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface CatalogReferenceNonNullableFields {
    catalogItemId: string;
    appId: string;
}
interface BackInStockNotificationRequestNonNullableFields {
    catalogReference?: CatalogReferenceNonNullableFields;
    email: string;
    status: Status;
}
export interface CreateBackInStockNotificationRequestResponseNonNullableFields {
    request?: BackInStockNotificationRequestNonNullableFields;
}
export interface GetBackInStockNotificationRequestResponseNonNullableFields {
    request?: BackInStockNotificationRequestNonNullableFields;
}
export interface MarkAsNotificationSentResponseNonNullableFields {
    request?: BackInStockNotificationRequestNonNullableFields;
}
export interface QueryBackInStockNotificationRequestsResponseNonNullableFields {
    requests: BackInStockNotificationRequestNonNullableFields[];
}
interface BackInStockNotificationRequestsCountNonNullableFields {
    catalogReference?: CatalogReferenceNonNullableFields;
    count: number;
}
export interface GetBackInStockNotificationRequestsCountByCatalogReferencesResponseNonNullableFields {
    countsPerCatalogReference: BackInStockNotificationRequestsCountNonNullableFields[];
}
export {};
