/**
 * The back in stock notification request allows a customer to receive a notifiction when a specific item
 * is available again. The request includes information about the person making the request, the item
 * they want to receive a notification for, and the status of the notification.
 */
export interface BackInStockNotificationRequest {
    /**
     * Request ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Catalog and item reference that the notification request is for.
     *
     * Includes IDs for the catalog and item it came from, as well as additional, optional information.
     */
    catalogReference?: CatalogReference;
    /** Email address to send notification to about item being back in stock. */
    email?: string;
    /**
     * Contact ID for the contact with this `email`.
     *
     * If a contact does not already exist with the email address submitted when creating this request, then a new contact is created.
     * For more information about contacts, see the Contacts API.
     * @readonly
     */
    contactId?: string | null;
    /**
     * Status of the notification.
     *
     * `status` is set to `RECEIVED` when the notification request is created. The `status` changes once a notification email is sent for this request object:
     * + When a notification email is sent through the site, either automatically or with the `reportItemsBackInStock()` function, then the `status` is briefly set to `PROCESSING` and then set to `NOTIFICATION_SENT` if the email is successul, and `FAILED` if it fails.
     * + When a notification email is sent offline, use the `markAsNotificationSent()` function to set `status` to `NOTIFICATION_SENT`.
     * @readonly
     */
    status?: Status;
    /**
     * Whether a notification was sent automatically.
     *
     * `autoNotified` is empty when the notification request is created and is not returned until the field has a value. `autoNotified` receives a value when a notification email is sent for this request object.
     *
     * `autoNotified` sets to `true` if the notification is sent through the site, either automatically or with the `reportItemsBackInStock()` function. If the notification email is sent offline but the `status` is updated with the `markAsNotificationSent()` function, then `autoNotified` sets to `false`.
     * @readonly
     */
    autoNotified?: boolean | null;
    /**
     * Date and time the notification request was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /** Item URL for this request. */
    itemUrl?: string | null;
}
/** Used for grouping line items. Sent when an item is added to a cart, checkout, or order. */
export interface CatalogReference {
    /** ID of the item within the catalog it belongs to. */
    catalogItemId?: string;
    /**
     * ID of the app providing the catalog.
     *
     * You can get your app's ID from its page in the [app dashboard](https://dev.wix.com/dc3/my-apps/).
     *
     * For items from Wix catalogs, the following values always apply:
     * + Wix Stores: `"215238eb-22a5-4c36-9e7b-e7c08025e04e"`
     * + Wix Bookings: `"13d21c63-b5ec-5912-8397-c3a5ddb27a97"`
     * + Wix Restaurants: `"9a5d83fd-8570-482e-81ab-cfa88942ee60"`
     */
    appId?: string;
    /**
     * Additional item details in key:value pairs. Use this optional field to provide more specificity with item selection. The `options` field values differ depending on which catalog is providing the items.
     *
     * For products and variants from a Wix Stores catalog, learn more about [eCommerce integration](https://dev.wix.com/docs/rest/business-solutions/stores/catalog/e-commerce-integration).
     */
    options?: Record<string, any> | null;
}
export declare enum Status {
    UNSPECIFIED = "UNSPECIFIED",
    /** initial status of all new requests */
    RECEIVED = "RECEIVED",
    PROCESSING = "PROCESSING",
    NOTIFICATION_SENT = "NOTIFICATION_SENT",
    FAILED = "FAILED"
}
export interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** tell us why you're invalidating the cache. You don't need to add your app name */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
export interface InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
}
export interface App {
    /** The AppDefId */
    appDefId?: string;
    /** The instance Id */
    instanceId?: string;
}
export interface Page {
    /** the msid the page is on */
    metaSiteId?: string;
    /** Invalidate by Page ID */
    pageId?: string;
}
export interface URI {
    /** the msid the URI is on */
    metaSiteId?: string;
    /** URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes */
    uriPath?: string;
}
export interface File {
    /** the msid the file is related to */
    metaSiteId?: string;
    /** Invalidate by filename (for media files such as PDFs) */
    fileName?: string;
}
export interface CreateBackInStockNotificationRequestRequest {
    /**
     * Notification request information.
     *
     * Includes details for the out of stock item and the email address
     * requesting to be notified when it's back in stock.
     */
    request: BackInStockNotificationRequest;
    /** Item details to include in the notification when the item is back in stock. */
    itemDetails: BackInStockItemDetails;
}
export interface BackInStockItemDetails {
    /** Item name. */
    name?: string;
    /** Item price. */
    price?: string;
    /** Item image. */
    image?: string;
}
export interface CreateBackInStockNotificationRequestResponse {
    /** Created back in stock notification request. */
    request?: BackInStockNotificationRequest;
}
export interface GetBackInStockNotificationRequestRequest {
    /** ID of the notification request to retrieve. */
    _id: string;
}
export interface GetBackInStockNotificationRequestResponse {
    /** Retrieved back in stock notification request. */
    request?: BackInStockNotificationRequest;
}
export interface DeleteBackInStockNotificationRequestRequest {
    /** ID of the notification request to delete. */
    _id: string;
}
export interface DeleteBackInStockNotificationRequestResponse {
}
export interface MarkAsNotificationSentRequest {
    /** ID of the notification request to mark. */
    _id: string;
}
export interface MarkAsNotificationSentResponse {
    /** Marked back in stock notification request. */
    request?: BackInStockNotificationRequest;
}
export interface QueryBackInStockNotificationRequestsRequest {
    /** Query options. */
    query: PlatformQuery;
}
export interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting[];
}
/** @oneof */
export interface PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
export interface PlatformPaging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
export interface QueryBackInStockNotificationRequestsResponse {
    /** Retrieved back in stock requests. */
    requests?: BackInStockNotificationRequest[];
    /** Details on the paged set of results returned. */
    metadata?: PlatformPagingMetadata;
}
export interface PlatformPagingMetadata {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors;
}
export interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
export interface GetBackInStockNotificationRequestsCountByCatalogReferencesRequest {
    /** `catalogReference` items to retrieve the notification request for. */
    catalogReferences: CatalogReference[];
}
export interface GetBackInStockNotificationRequestsCountByCatalogReferencesResponse {
    /** Amount of back in stock notifications for each of the retrieved `catalogReference` items. */
    countsPerCatalogReference?: BackInStockNotificationRequestsCount[];
}
/** Maps each back in stock CatalogReference to the results (the number of unique occurrences). */
export interface BackInStockNotificationRequestsCount {
    /**
     * Catalog and item reference.
     *
     * Includes IDs and additional, optional information related to the item.
     */
    catalogReference?: CatalogReference;
    /** The number of unique back in stock requests for given `catalogReference`. */
    count?: number;
}
export interface ReportItemsBackInStockRequest {
    /**
     * `catalogReference` item to send notifications for.
     *
     * Cannot be used with `requestIds`.
     */
    catalogReference?: CatalogReference;
    /**
     * IDs of requests to send notifications for.
     *
     * Cannot be used with `catalogReference`.
     */
    requestIds?: string[];
    /**
     * Item details to use in notifications.
     *
     * `itemDetails` may populate dynamic valyes in the notification template, as follows:
     * + `itemDetails.name` passes to the template as `item.name`
     * + `itemDetails.price` passes to the template as `item.price`
     * + `itemDetails.image.url` passes to the template as `item.image.url`
     *
     * Use `extraAutomationTemplateParameters` to pass additional dynamic values.
     */
    itemDetails: BackInStockItemDetails;
    /** Additional key-value pairs to pass to the back in stock notification template. */
    extraAutomationTemplateParameters?: Record<string, string>;
}
export interface ReportItemsBackInStockResponse {
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entity?: string;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
export interface ActionEvent {
    body?: string;
}
export interface Empty {
}
export interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface CatalogReferenceNonNullableFields {
    catalogItemId: string;
    appId: string;
}
export interface BackInStockNotificationRequestNonNullableFields {
    catalogReference?: CatalogReferenceNonNullableFields;
    email: string;
    status: Status;
}
export interface CreateBackInStockNotificationRequestResponseNonNullableFields {
    request?: BackInStockNotificationRequestNonNullableFields;
}
export interface GetBackInStockNotificationRequestResponseNonNullableFields {
    request?: BackInStockNotificationRequestNonNullableFields;
}
export interface MarkAsNotificationSentResponseNonNullableFields {
    request?: BackInStockNotificationRequestNonNullableFields;
}
export interface QueryBackInStockNotificationRequestsResponseNonNullableFields {
    requests: BackInStockNotificationRequestNonNullableFields[];
}
interface BackInStockNotificationRequestsCountNonNullableFields {
    catalogReference?: CatalogReferenceNonNullableFields;
    count: number;
}
export interface GetBackInStockNotificationRequestsCountByCatalogReferencesResponseNonNullableFields {
    countsPerCatalogReference: BackInStockNotificationRequestsCountNonNullableFields[];
}
export interface BaseEventMetadata {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
export interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
export interface BackInStockNotificationRequestCreatedEnvelope {
    entity: BackInStockNotificationRequest;
    metadata: EventMetadata;
}
/** @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionId ECOM.READ_BACK_IN_STOCK_NOTIFICATION_REQUESTS
 * @webhook
 * @eventType wix.ecom.v1.back_in_stock_notification_request_created
 * @documentationMaturity preview
 */
export declare function onBackInStockNotificationRequestCreated(handler: (event: BackInStockNotificationRequestCreatedEnvelope) => void | Promise<void>): void;
export interface BackInStockNotificationRequestUpdatedEnvelope {
    entity: BackInStockNotificationRequest;
    metadata: EventMetadata;
}
/** @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionId ECOM.READ_BACK_IN_STOCK_NOTIFICATION_REQUESTS
 * @webhook
 * @eventType wix.ecom.v1.back_in_stock_notification_request_updated
 * @documentationMaturity preview
 */
export declare function onBackInStockNotificationRequestUpdated(handler: (event: BackInStockNotificationRequestUpdatedEnvelope) => void | Promise<void>): void;
export interface BackInStockNotificationRequestDeletedEnvelope {
    metadata: EventMetadata;
}
/** @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionId ECOM.READ_BACK_IN_STOCK_NOTIFICATION_REQUESTS
 * @webhook
 * @eventType wix.ecom.v1.back_in_stock_notification_request_deleted
 * @documentationMaturity preview
 */
export declare function onBackInStockNotificationRequestDeleted(handler: (event: BackInStockNotificationRequestDeletedEnvelope) => void | Promise<void>): void;
/**
 * Creates a back in stock notification request.
 *
 * If a notification request already exists for the same `catalogReference` and `email`,
 * then a new one isn't created and the existing request is returned.
 * @param request - Notification request information.
 *
 * Includes details for the out of stock item and the email address
 * requesting to be notified when it's back in stock.
 * @param itemDetails - Item details to include in the notification when the item is back in stock.
 * @public
 * @documentationMaturity preview
 * @requiredField itemDetails
 * @requiredField itemDetails.name
 * @requiredField itemDetails.price
 * @requiredField request
 * @requiredField request.catalogReference
 * @requiredField request.catalogReference.appId
 * @requiredField request.catalogReference.catalogItemId
 * @requiredField request.email
 * @permissionId ECOM.CREATE_BACK_IN_STOCK_NOTIFICATION_REQUESTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @returns Created back in stock notification request.
 * @fqn com.wixpress.ecom.back.in.stock.BackInStockNotificationRequestService.CreateBackInStockNotificationRequest
 */
export declare function createBackInStockNotificationRequest(request: BackInStockNotificationRequest, itemDetails: BackInStockItemDetails): Promise<BackInStockNotificationRequest & BackInStockNotificationRequestNonNullableFields>;
/**
 * Retrieves a back in stock notification request.
 * @param _id - ID of the notification request to retrieve.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId ECOM.READ_BACK_IN_STOCK_NOTIFICATION_REQUESTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @applicableIdentity APP
 * @returns Retrieved back in stock notification request.
 * @fqn com.wixpress.ecom.back.in.stock.BackInStockNotificationRequestService.GetBackInStockNotificationRequest
 */
export declare function getBackInStockNotificationRequest(_id: string): Promise<BackInStockNotificationRequest & BackInStockNotificationRequestNonNullableFields>;
/**
 * Deletes a back in stock notification request.
 * @param _id - ID of the notification request to delete.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId ECOM.MODIFY_BACK_IN_STOCK_NOTIFICATION_REQUESTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @applicableIdentity APP
 * @fqn com.wixpress.ecom.back.in.stock.BackInStockNotificationRequestService.DeleteBackInStockNotificationRequest
 */
export declare function deleteBackInStockNotificationRequest(_id: string): Promise<void>;
/**
 * Sets `status` of a back in stock request to `NOTIFICATION_SENT`.
 *
 * Use this function if the notification is sent manually offline. If the notification is sent automatically or with the `reportItemsBackInStock()` function, then `status` updates on its own.
 * @param _id - ID of the notification request to mark.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId ECOM.MODIFY_BACK_IN_STOCK_NOTIFICATION_REQUESTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @applicableIdentity APP
 * @fqn com.wixpress.ecom.back.in.stock.BackInStockNotificationRequestService.MarkAsNotificationSent
 */
export declare function markAsNotificationSent(_id: string): Promise<MarkAsNotificationSentResponse & MarkAsNotificationSentResponseNonNullableFields>;
/**
 * Creates a query to retrieve a list of back in stock notification requests.
 *
 * The `queryBackInStockNotificationRequests()` method builds a query to retrieve a list of back in stock notification requests and returns a `RequestsQueryBuilder` object.
 *
 * The returned object contains the query definition, which is typically used to run the query using the `find()` method.
 *
 * You can refine the query by chaining `RequestsQueryBuilder` methods onto the query. `RequestsQueryBuilder` methods enable you to sort, filter, and control the results that `queryBackInStockNotificationRequests()` returns.
 *
 * The following `RequestsQueryBuilder` methods are supported for `queryBackInStockNotificationRequests()`. For a full description of the Requests object, see the object returned for the `items` property in `RequestsQueryResult`."
 * @public
 * @documentationMaturity preview
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionId ECOM.READ_BACK_IN_STOCK_NOTIFICATION_REQUESTS
 * @applicableIdentity APP
 * @fqn com.wixpress.ecom.back.in.stock.BackInStockNotificationRequestService.QueryBackInStockNotificationRequests
 */
export declare function queryBackInStockNotificationRequests(): RequestsQueryBuilder;
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
export interface RequestsQueryResult extends QueryCursorResult {
    items: BackInStockNotificationRequest[];
    query: RequestsQueryBuilder;
    next: () => Promise<RequestsQueryResult>;
    prev: () => Promise<RequestsQueryResult>;
}
export interface RequestsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    eq: (propertyName: '_id' | 'contactId' | 'status' | 'autoNotified' | '_createdDate' | 'itemUrl', value: any) => RequestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ne: (propertyName: '_id' | 'contactId' | 'status' | 'autoNotified' | '_createdDate' | 'itemUrl', value: any) => RequestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ge: (propertyName: '_createdDate', value: any) => RequestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    gt: (propertyName: '_createdDate', value: any) => RequestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    le: (propertyName: '_createdDate', value: any) => RequestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    lt: (propertyName: '_createdDate', value: any) => RequestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     * @documentationMaturity preview
     */
    startsWith: (propertyName: '_id' | 'contactId' | 'itemUrl', value: string) => RequestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasSome: (propertyName: '_id' | 'contactId' | 'status' | 'autoNotified' | '_createdDate' | 'itemUrl', value: any[]) => RequestsQueryBuilder;
    /** @documentationMaturity preview */
    in: (propertyName: '_id' | 'contactId' | 'status' | 'autoNotified' | '_createdDate' | 'itemUrl', value: any) => RequestsQueryBuilder;
    /** @documentationMaturity preview */
    exists: (propertyName: '_id' | 'contactId' | 'status' | 'autoNotified' | '_createdDate' | 'itemUrl', value: boolean) => RequestsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    ascending: (...propertyNames: Array<'_id' | 'contactId' | 'status' | 'autoNotified' | '_createdDate' | 'itemUrl'>) => RequestsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    descending: (...propertyNames: Array<'_id' | 'contactId' | 'status' | 'autoNotified' | '_createdDate' | 'itemUrl'>) => RequestsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
     * @documentationMaturity preview
     */
    limit: (limit: number) => RequestsQueryBuilder;
    /** @param cursor - A pointer to specific record
     * @documentationMaturity preview
     */
    skipTo: (cursor: string) => RequestsQueryBuilder;
    /** @documentationMaturity preview */
    find: () => Promise<RequestsQueryResult>;
}
/**
 * Retrieves the amount of back in stock requests for a given `catalogReference` item.
 * @param catalogReferences - `catalogReference` items to retrieve the notification request for.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogReferences
 * @permissionId ECOM.READ_BACK_IN_STOCK_NOTIFICATION_REQUESTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @applicableIdentity APP
 * @fqn com.wixpress.ecom.back.in.stock.BackInStockNotificationRequestService.GetBackInStockNotificationRequestsCountByCatalogReferences
 */
export declare function getBackInStockNotificationRequestsCountByCatalogReferences(catalogReferences: CatalogReference[]): Promise<GetBackInStockNotificationRequestsCountByCatalogReferencesResponse & GetBackInStockNotificationRequestsCountByCatalogReferencesResponseNonNullableFields>;
/**
 * Sends notifications for back in stock requests.
 *
 * > **Important:**
 * > Automations must be turned on in a [site's dashboard](https://www.wix.com/my-account/site-selector/?buttonText=Go%20to%20Back-in-Stock&title=Select%20a%20Site&autoSelectOnSingleSite=true&actionUrl=https://www.wix.com/dashboard/{{metaSiteId}}/store/back-in-stock) for notifications to send.
 *
 * This endpoint triggers notifications for requests in 1 of 2 ways:
 * 1. For a specific item, with the `catalogReference` information.
 * 2. For specific requests, with `requestIds`.
 *
 * `itemDetails` are required and may populate dynamic values in the notification template, as follows:
 * + `itemDetails.name` passes to the template as `item.name`
 * + `itemDetails.price` passes to the template as `item.price`
 * + `itemDetails.image.url` passes to the template as `item.image.url`
 *
 * If the notification template doesn't include `item.price`, `item.name`, or `item.image.url`, values should
 * be passed in `extraAutomationTemplateParameters`.
 *
 * After this endpoint is called, the `status` for the request will update to `NOTIFICATION_SENT` if it sends
 * successfully, or to `FAILED` if it fails to send.
 * @param itemDetails - Item details to use in notifications.
 *
 * `itemDetails` may populate dynamic valyes in the notification template, as follows:
 * + `itemDetails.name` passes to the template as `item.name`
 * + `itemDetails.price` passes to the template as `item.price`
 * + `itemDetails.image.url` passes to the template as `item.image.url`
 *
 * Use `extraAutomationTemplateParameters` to pass additional dynamic values.
 * @public
 * @documentationMaturity preview
 * @requiredField itemDetails
 * @requiredField itemDetails.name
 * @requiredField itemDetails.price
 * @param options - Report options.
 * @permissionId ECOM.MODIFY_BACK_IN_STOCK_NOTIFICATION_REQUESTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @applicableIdentity APP
 * @fqn com.wixpress.ecom.back.in.stock.BackInStockNotificationRequestService.ReportItemsBackInStock
 */
export declare function reportItemsBackInStock(itemDetails: BackInStockItemDetails, options?: ReportItemsBackInStockOptions): Promise<void>;
export interface ReportItemsBackInStockOptions {
    /**
     * `catalogReference` item to send notifications for.
     *
     * Cannot be used with `requestIds`.
     */
    catalogReference?: CatalogReference;
    /**
     * IDs of requests to send notifications for.
     *
     * Cannot be used with `catalogReference`.
     */
    requestIds?: string[];
    /** Additional key-value pairs to pass to the back in stock notification template. */
    extraAutomationTemplateParameters?: Record<string, string>;
}
export {};
