export interface OrderTransactions {
    /** Order ID. */
    orderId?: string;
    /** Record of payments made to the merchant. */
    payments?: Payment[];
    /** Record of refunds made to the buyer. */
    refunds?: Refund[];
}
export interface Payment extends PaymentPaymentDetailsOneOf, PaymentReceiptInfoOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
    /**
     * Payment ID.
     * @readonly
     */
    _id?: string | null;
    /** Date and time the payment was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided. */
    _createdDate?: Date | null;
    /**
     * Date and time the payment was last updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Payment amount. */
    amount?: Price;
    /**
     * Whether refunds for this payment are disabled.
     * + `true`: This payment is not refundable.
     * + `false`: This payment may be refunded. However, this ultimately depends on the payment provider.
     */
    refundDisabled?: boolean;
}
/** @oneof */
export interface PaymentPaymentDetailsOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
}
/** @oneof */
export interface PaymentReceiptInfoOneOf {
}
export interface RegularPaymentDetails extends RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /** Wix Payments order ID. */
    paymentOrderId?: string | null;
    /**
     * Payment gateway's transaction ID. This ID can be used with the Wix Payments [Transactions API](https://dev.wix.com/docs/rest/api-reference/wix-payments/transactions/introduction).
     * This field is only returned when the value of `offline_payment` is `false`.
     */
    gatewayTransactionId?: string | null;
    /**
     * Payment method. Non-exhaustive list of supported values:
     * + `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     */
    paymentMethod?: string | null;
    /** Transaction ID in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for offline payments. */
    providerTransactionId?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
    /** Payment status. */
    status?: TransactionStatus;
    /** Whether there is a payment agreement that allows for future charges. */
    savedPaymentMethod?: boolean;
    /** Authorization details. */
    authorizationDetails?: AuthorizationDetails;
}
/** @oneof */
export interface RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
export declare enum TransactionStatus {
    UNDEFINED = "UNDEFINED",
    APPROVED = "APPROVED",
    PENDING = "PENDING",
    PENDING_MERCHANT = "PENDING_MERCHANT",
    CANCELED = "CANCELED",
    DECLINED = "DECLINED",
    REFUNDED = "REFUNDED",
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    AUTHORIZED = "AUTHORIZED",
    VOIDED = "VOIDED"
}
export interface CreditCardPaymentMethodDetails {
    /** The last 4 digits of the card number. */
    lastFourDigits?: string | null;
    /** Card issuer's brand. */
    brand?: string | null;
}
export interface AuthorizationDetails {
    /**
     * Whether the authorized payment is of a delayed capture.
     * @readonly
     */
    delayedCapture?: boolean;
    /** Date and time the payment was authorized in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    authorizedDate?: Date | null;
    /**
     * List of captures associated with payment
     * In case of failed it can be replaced with new one with PENDING or SUCCESS statuses
     */
    captures?: AuthorizationCapture[];
    /** Void associated with payment */
    void?: AuthorizationVoid;
    /** Scheduled action for this transaction */
    scheduledAction?: ScheduledAction;
}
export interface AuthorizationCapture {
    /**
     * Capture ID.
     * @readonly
     */
    _id?: string | null;
    /** Status of this capture action */
    status?: AuthorizationCaptureStatus;
    /** Amount of this capture */
    amount?: Price;
    /** Date and time the capture was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    _createdDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
}
export declare enum AuthorizationCaptureStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Capture operation still in progress. */
    PENDING = "PENDING",
    /** Capture operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Capture operation failed. */
    FAILED = "FAILED"
}
export interface Price {
    /** Amount. */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
}
export interface AuthorizationActionFailureDetails {
    failureCode?: string;
}
export interface AuthorizationVoid {
    /** Status of this void action */
    status?: AuthorizationVoidStatus;
    /** Date and time the void was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    voidedDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
    /** Reason of void action */
    reason?: Reason;
}
export declare enum AuthorizationVoidStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Void operation still in progress. */
    PENDING = "PENDING",
    /** Void operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Void operation failed. */
    FAILED = "FAILED"
}
/** Reason the authorization was voided. */
export declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** Authorization was voided by user. */
    MANUAL = "MANUAL",
    /** Authorization passed execution date. */
    SCHEDULED = "SCHEDULED"
}
export interface ScheduledAction {
    /** Type of the action. */
    actionType?: ActionType;
    /** The date and time of the action. */
    executionDate?: Date | null;
}
export declare enum ActionType {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    VOID = "VOID",
    CAPTURE = "CAPTURE"
}
export interface GiftCardPaymentDetails {
    /** Gift card payment ID. */
    giftCardPaymentId?: string;
    /** ID of the app that created the gift card. */
    appId?: string;
    /**
     * Whether the gift card is voided.
     * @readonly
     */
    voided?: boolean;
}
export interface MembershipPaymentDetails {
    /** Membership ID. */
    membershipId?: string;
    /** ID of the line item this membership applies to. */
    lineItemId?: string;
    /** Payment status. */
    status?: MembershipPaymentStatus;
    /** Membership name. */
    name?: MembershipName;
    /** The transaction ID in the membership system. Can be used to void the transaction. */
    externalTransactionId?: string | null;
    /**
     * Whether the membership is voided.
     * @readonly
     */
    voided?: boolean;
    /** ID of the application providing this payment option. */
    providerAppId?: string;
}
export declare enum MembershipPaymentStatus {
    /** Payment was charged. */
    CHARGED = "CHARGED",
    /** The attempt to charge the payment failed, for example, due to lack of credits. */
    CHARGE_FAILED = "CHARGE_FAILED"
}
export interface MembershipName {
    /** Membership name. */
    original?: string;
    /** Translated membership name. Defaults to `original` when not provided. */
    translated?: string | null;
}
export interface WixReceiptInfo {
    /** Receipt ID */
    receiptId?: string;
    /** Display number of receipt */
    displayNumber?: string | null;
}
export interface ExternalReceiptInfo {
    /** External receipt ID */
    receiptId?: string | null;
    /** ID of the app providing the receipt */
    appId?: string | null;
    /** Display number of receipt */
    displayNumber?: string | null;
}
export interface Refund {
    /**
     * Refund ID.
     * @readonly
     */
    _id?: string;
    /** List of transactions. */
    transactions?: RefundTransaction[];
    /** Refund business details. */
    details?: RefundDetails;
    /**
     * Date and time the refund was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     */
    _createdDate?: Date | null;
}
export interface RefundTransaction {
    /** ID of the payment associated with this refund. */
    paymentId?: string;
    /** Refund amount. */
    amount?: Price;
    /** Refund status. */
    refundStatus?: RefundStatus;
    /** Optional details of current refund status. */
    refundStatusInfo?: RefundStatusInfo;
    /**
     * Payment gateway's refund ID. This ID can be used with the Wix Payments [Transactions API](https://dev.wix.com/docs/rest/api-reference/wix-payments/transactions/introduction).
     * This field is only returned when the value of `external_refund` is `false`.
     */
    gatewayRefundId?: string | null;
    /** ID of the refund in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for external refunds. */
    providerRefundId?: string | null;
    /** Whether refund was made externally and manually on the payment provider's side. */
    externalRefund?: boolean;
}
/** Refund transaction status. */
export declare enum RefundStatus {
    /** Refund was initiated on payment provider side. PENDING status was assigned by provider. */
    PENDING = "PENDING",
    /** Refund transaction succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Refund transaction failed. */
    FAILED = "FAILED",
    /** Refund request acknowledged, and will be executed soon. */
    SCHEDULED = "SCHEDULED",
    /** Refund was initiated on payment provider side. */
    STARTED = "STARTED"
}
export interface RefundStatusInfo {
}
/** Business model of a refund request */
export interface RefundDetails {
    /** Order line item IDs and quantities that were refunded. */
    items?: RefundItem[];
    /** Whether the shipping fee was also refunded. */
    shippingIncluded?: boolean;
    /** Reason for the refund, provided by customer (optional). */
    reason?: string | null;
}
export interface RefundItem {
    /** Line item ID the refunded line item. */
    lineItemId?: string;
    /** Line item quantity refunded. */
    quantity?: number;
}
export interface LineItemRefund {
}
export interface AdditionalFeeRefund {
}
export interface ShippingRefund {
}
export interface AggregatedRefundSummary {
}
export interface SnapshotMessage {
    _id?: string;
    opType?: number;
}
export interface IndexingMessage {
    _id?: string;
    opType?: number;
    requiredVersions?: string[];
}
export interface DiffmatokyPayload {
    left?: string;
    right?: string;
    compareChannel?: string;
    entityId?: string;
    errorInformation?: ErrorInformation;
    tags?: string[];
}
export interface ErrorInformation {
    stackTrace?: string;
}
export interface OrderRefunded {
    /**
     * Refund ID.
     * @readonly
     */
    refundId?: string;
    /**
     * Refunded order data.
     * @readonly
     */
    order?: Order;
}
export interface Order {
    /**
     * Order ID (auto-generated upon order creation).
     * @readonly
     */
    _id?: string | null;
    /**
     * Order number displayed in the owner's store (auto-generated).
     * @readonly
     */
    number?: number;
    /**
     * Order creation date and time.
     * @readonly
     */
    dateCreated?: Date | null;
    /** Buyer information. */
    buyerInfo?: BuyerInfo;
    /** Currency used for the pricing of this order in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format. */
    currency?: string | null;
    /** Weight unit used in this store. */
    weightUnit?: WeightUnit;
    /** Totals for order's line items. */
    totals?: Totals;
    /** Billing information. */
    billingInfo?: BillingInfo;
    /** Shipping information. */
    shippingInfo?: ShippingInfo;
    /** A note added by the buyer. */
    buyerNote?: string | null;
    /**
     * Deprecated.
     * @readonly
     * @deprecated
     */
    read?: boolean;
    /**
     * Whether or not the order was archived.
     * @readonly
     */
    archived?: boolean;
    /** Current status of the payment. */
    paymentStatus?: PaymentStatus;
    /**
     * Order's current fulfillment status (whether the order received a tracking number or was delivered/picked up).
     * @readonly
     */
    fulfillmentStatus?: FulfillmentStatus;
    /** Line items ordered. */
    lineItems?: LineItem[];
    /**
     * Log of updates related to the order.
     * @readonly
     */
    activities?: Activity[];
    /** Invoice information. */
    invoiceInfo?: V2InvoiceInfo;
    /**
     * Order fulfillment information.
     * @readonly
     */
    fulfillments?: Fulfillment[];
    /** Discount information. */
    discount?: Discount;
    /** Custom field information. */
    customField?: CustomField;
    /** Shopping cart ID. */
    cartId?: string | null;
    /**
     * Language for communication with the buyer. Defaults to the site language.
     * For a site that supports multiple languages, this is the language the buyer selected.
     */
    buyerLanguage?: string | null;
    /** Information about the sales channel that submitted this order. */
    channelInfo?: ChannelInfo;
    /**
     * Identity of the order's initiator.
     * @readonly
     */
    enteredBy?: EnteredBy;
    /**
     * Date and time of latest update.
     * @readonly
     */
    lastUpdated?: Date | null;
    /** Subscription information. */
    subscriptionInfo?: SubscriptionInfo;
    /**
     * Order’s unique numeric ID.
     * Primarily used for sorting and filtering when crawling all orders.
     * @readonly
     */
    numericId?: string;
    /**
     * Refund information.
     * @readonly
     */
    refunds?: V2Refund[];
}
/** Buyer Info */
export interface BuyerInfo {
    /** Wix customer ID */
    _id?: string | null;
    /**
     * Deprecated (use identityType instead)
     * @readonly
     * @deprecated
     */
    type?: IdentityType;
    /** Customer type */
    identityType?: IdentityType;
    /**
     * Customer's first name
     * @readonly
     */
    firstName?: string;
    /**
     * Customer's last name
     * @readonly
     */
    lastName?: string;
    /**
     * Customer's phone number
     * @readonly
     */
    phone?: string | null;
    /**
     * Customer's email address
     * @readonly
     */
    email?: string;
}
export declare enum IdentityType {
    UNSPECIFIED_IDENTITY_TYPE = "UNSPECIFIED_IDENTITY_TYPE",
    /** Site member */
    MEMBER = "MEMBER",
    /** Contact */
    CONTACT = "CONTACT"
}
export declare enum WeightUnit {
    /** Weight unit can't be classified, due to an error */
    UNSPECIFIED_WEIGHT_UNIT = "UNSPECIFIED_WEIGHT_UNIT",
    /** Kilograms */
    KG = "KG",
    /** Pounds */
    LB = "LB"
}
export interface Totals {
    /** Subtotal of all the line items, before tax. */
    subtotal?: string;
    /** Total shipping price, before tax. */
    shipping?: string | null;
    /** Total tax. */
    tax?: string | null;
    /** Total calculated discount value. */
    discount?: string | null;
    /** Total price charged. */
    total?: string;
    /**
     * Total items weight.
     * @readonly
     */
    weight?: string;
    /**
     * Total number of line items.
     * @readonly
     */
    quantity?: number;
    /**
     * Total refund.
     * @readonly
     */
    refund?: string | null;
    /** Total calculated gift card value. */
    giftCard?: string | null;
}
export interface BillingInfo {
    /** Payment method used for this order */
    paymentMethod?: string | null;
    /**
     * Deprecated (use paymentProviderTransactionId instead)
     * @readonly
     * @deprecated
     */
    externalTransactionId?: string | null;
    /** Transaction ID from payment provider (e.g., PayPal, Square, Stripe) transaction ID */
    paymentProviderTransactionId?: string | null;
    /** Transaction ID from payment gateway (e.g., Wix Payments) */
    paymentGatewayTransactionId?: string | null;
    /** Full billing address */
    address?: Address;
    /**
     * Payment date
     * @readonly
     */
    paidDate?: Date | null;
    /** Whether order can be refunded by payment provider (manually or automatic) */
    refundableByPaymentProvider?: boolean | null;
}
export interface Address extends AddressAddressLine1OptionsOneOf {
    /** Address line 1 (free text) */
    addressLine1?: string;
    /** Address line 1 (street) */
    street?: Street;
    /** Addressee name */
    fullName?: FullName;
    /** Country code (2 letters) */
    country?: string | null;
    /** State or district */
    subdivision?: string | null;
    /** City name */
    city?: string | null;
    /** ZIP/postal code */
    zipCode?: string | null;
    /** Phone number */
    phone?: string | null;
    /** Company name */
    company?: string | null;
    /** Email address */
    email?: string | null;
    /** address line */
    addressLine2?: string | null;
    /** Tax information (for Brazil only) */
    vatId?: VatId;
}
/** @oneof */
export interface AddressAddressLine1OptionsOneOf {
    /** Address line 1 (free text) */
    addressLine1?: string;
    /** Address line 1 (street) */
    street?: Street;
}
export interface FullName {
    /** Customer's first name */
    firstName?: string;
    /** Customer's last name */
    lastName?: string;
}
export interface Street {
    /** Street number */
    number?: string;
    /** Street name */
    name?: string;
}
export interface VatId {
    /** Customer's tax ID. */
    number?: string;
    /**
     * Tax type.
     * + `CPF`: For individual tax payers.
     * + `CNPJ`: For corporations.
     */
    type?: VatType;
}
/** Brazilian tax info types */
export declare enum VatType {
    /** When the tax info type can't be classified, due to an error */
    UNSPECIFIED_TAX_TYPE = "UNSPECIFIED_TAX_TYPE",
    /** CPF - for individual tax payers */
    CPF = "CPF",
    /** CNPJ - for corporations */
    CNPJ = "CNPJ"
}
export interface ShippingInfo extends ShippingInfoDetailsOneOf {
    /** Shipment details (when this object describes shipment). */
    shipmentDetails?: ShipmentDetails;
    /** Pickup details (when this object describes pickup). */
    pickupDetails?: PickupDetails;
    /** Shipping option name. */
    deliveryOption?: string;
    /** Shipping option delivery time. */
    estimatedDeliveryTime?: string | null;
    /**
     * Deprecated - Latest expected delivery date.
     * @deprecated
     */
    deliverByDate?: Date | null;
    /** Shipping region. */
    shippingRegion?: string | null;
    /**
     * Unique code of provided shipping option. For example, `"usps_std_overnight"`.
     * @readonly
     */
    code?: string | null;
}
/** @oneof */
export interface ShippingInfoDetailsOneOf {
    /** Shipment details (when this object describes shipment). */
    shipmentDetails?: ShipmentDetails;
    /** Pickup details (when this object describes pickup). */
    pickupDetails?: PickupDetails;
}
export interface ShipmentDetails {
    /** Shipping destination address. */
    address?: Address;
    /**
     * Deprecated (use fulfillments instead).
     * @readonly
     * @deprecated
     */
    trackingInfo?: TrackingInfo;
    /** Discount applied for shipping. */
    discount?: string | null;
    /** Tax applied for shipping. */
    tax?: string | null;
    /** Price data. */
    priceData?: ShippingPriceData;
}
export interface TrackingInfo {
    /**
     * Tracking number
     * @readonly
     */
    trackingNumber?: string | null;
    /**
     * Shipping provider
     * @readonly
     */
    shippingProvider?: string | null;
    /**
     * Tracking link
     * @readonly
     */
    trackingLink?: string | null;
}
export interface ShippingPriceData {
    /** Whether tax is included in the price. */
    taxIncludedInPrice?: boolean;
    /** Shipping price. */
    price?: string | null;
}
export interface PickupDetails {
    /** Pickup address. */
    pickupAddress?: PickupAddress;
    /**
     * Deprecated (use billingInfo instead).
     * @readonly
     * @deprecated
     */
    buyerDetails?: BuyerDetails;
    /** Store owner's pickup instructions. */
    pickupInstructions?: string | null;
}
export interface PickupAddress {
    /** Country code (3 letters) */
    country?: string;
    /** State/District */
    subdivision?: string | null;
    /** Address */
    addressLine1?: string;
    /** City */
    city?: string;
    /** ZIP/postal code */
    zipCode?: string;
}
export interface BuyerDetails {
    /** Addressee name */
    fullName?: FullName;
    /** Email address */
    email?: string;
    /** Phone number */
    phone?: string;
}
/** This might be extended in the future with pending orders statuses */
export declare enum PaymentStatus {
    /** Payment status can't be classified, due to an error */
    UNSPECIFIED_PAYMENT_STATUS = "UNSPECIFIED_PAYMENT_STATUS",
    /** Order is pending response from the payment provider */
    PENDING = "PENDING",
    /** Order is marked as not paid, and can be marked as paid later on. This is relevant for POS and offline orders */
    NOT_PAID = "NOT_PAID",
    /** The order is marked as paid */
    PAID = "PAID",
    /** Order was refunded, refund amount less than order total price */
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    /** Full order total price was refunded */
    FULLY_REFUNDED = "FULLY_REFUNDED",
    /** At least one payment was received and approved, covering less than total price amount */
    PARTIALLY_PAID = "PARTIALLY_PAID"
}
export declare enum FulfillmentStatus {
    /** None of the order items are fulfilled */
    NOT_FULFILLED = "NOT_FULFILLED",
    /**
     * All of the order items are fulfilled
     * Orders without shipping info are fulfilled automatically
     */
    FULFILLED = "FULFILLED",
    /** Order is canceled */
    CANCELED = "CANCELED",
    /** Some, but not all of the order items are fulfilled */
    PARTIALLY_FULFILLED = "PARTIALLY_FULFILLED"
}
export interface LineItem {
    /**
     * Line item ID (auto-generated, stable within this order only)
     * @readonly
     */
    index?: number | null;
    /** Line item quantity */
    quantity?: number;
    /**
     * Deprecated (use priceData instead)
     * @readonly
     * @deprecated
     */
    price?: string | null;
    /** Line item name */
    name?: string | null;
    /** Product name, translated into the customer's language */
    translatedName?: string | null;
    /** Line item product ID (optional for POS orders) */
    productId?: string | null;
    /**
     * Deprecated (use priceData instead)
     * @readonly
     * @deprecated
     */
    totalPrice?: string | null;
    /** Line item type (may be extended) */
    lineItemType?: LineItemType;
    /** Line item options ordered */
    options?: OptionSelection[];
    /** Line item custom text field entry */
    customTextFields?: CustomTextFieldSelection[];
    /** Line item weight */
    weight?: string | null;
    /** Primary media for preview of the line item */
    mediaItem?: MediaItem;
    /** Line item SKU */
    sku?: string | null;
    /** Line item notes */
    notes?: string | null;
    /** Line item variantId (from Stores Catalog) */
    variantId?: string | null;
    /** Line item fulfillerId from stores fulfillers. No value equals self fulfilled */
    fulfillerId?: string | null;
    /** Discount applied for this line item */
    discount?: string | null;
    /** Tax applied for this line item */
    tax?: string | null;
    /**
     * Deprecated (use priceData instead)
     * @readonly
     * @deprecated
     */
    taxIncludedInPrice?: boolean;
    /** Tax group ID */
    taxGroupId?: string | null;
    /** Price data */
    priceData?: LineItemPriceData;
}
export declare enum LineItemType {
    /** Line item type can't be classified, due to an error */
    UNSPECIFIED_LINE_ITEM_TYPE = "UNSPECIFIED_LINE_ITEM_TYPE",
    /** Physical item type */
    PHYSICAL = "PHYSICAL",
    /** Digital item type */
    DIGITAL = "DIGITAL",
    /** Custom item price */
    CUSTOM_AMOUNT_ITEM = "CUSTOM_AMOUNT_ITEM"
}
export interface OptionSelection {
    /** Option name */
    option?: string;
    /** Selected choice for this option */
    selection?: string;
}
export interface CustomTextFieldSelection {
    /** Custom text field name */
    title?: string;
    /** Custom text field value */
    value?: string;
}
export interface MediaItem {
    /**
     * Media type
     * @readonly
     */
    mediaType?: MediaItemType;
    /**
     * Media URL
     * @readonly
     */
    url?: string;
    /**
     * Media item width
     * @readonly
     */
    width?: number;
    /**
     * Media item height
     * @readonly
     */
    height?: number;
    /**
     * Deprecated
     * @deprecated
     */
    mediaId?: string | null;
    /** Media ID (for media items previously saved in Wix Media) */
    _id?: string | null;
    /** Media external URL */
    externalImageUrl?: string | null;
    /** Alternative text for presentation when media cannot be displayed */
    altText?: string | null;
}
export declare enum MediaItemType {
    /** Media item type can't be classified, due to an error */
    UNSPECIFIED_MEDIA_TYPE_ITEM = "UNSPECIFIED_MEDIA_TYPE_ITEM",
    /** Image item type */
    IMAGE = "IMAGE"
}
export interface LineItemPriceData {
    /** Whether tax is included in the price set for this line item */
    taxIncludedInPrice?: boolean;
    /** Line item price */
    price?: string;
    /**
     * Total price charged to the customer (per line item) after computation of quantity and discount
     * @readonly
     */
    totalPrice?: string | null;
}
export interface DigitalFile {
    /** id of the secure file in media */
    fileId?: string;
}
export interface Activity {
    /**
     * Activity item type
     * @readonly
     */
    type?: ActivityType;
    /**
     * Activity item author
     * @readonly
     */
    author?: string | null;
    /**
     * Comment added to activity item
     * @readonly
     */
    message?: string | null;
    /**
     * Activity item timestamp
     * @readonly
     */
    timestamp?: Date | null;
}
export declare enum ActivityType {
    /** Activity item type can't be classified, due to an error */
    UNSPECIFIED_ORDER_HISTORY_ITEM_TYPE = "UNSPECIFIED_ORDER_HISTORY_ITEM_TYPE",
    /** Store owner added a comment */
    MERCHANT_COMMENT = "MERCHANT_COMMENT",
    /** Order placed */
    ORDER_PLACED = "ORDER_PLACED",
    /** Order marked as paid, either by the store owner (for offline orders), or when an online transaction was confirmed */
    ORDER_PAID = "ORDER_PAID",
    /** Order shipping status set as fulfilled */
    ORDER_FULFILLED = "ORDER_FULFILLED",
    /** Order shipping status set as not fulfilled */
    ORDER_NOT_FULFILLED = "ORDER_NOT_FULFILLED",
    /** A download link was sent (relevant for orders with digital line items) */
    DOWNLOAD_LINK_SENT = "DOWNLOAD_LINK_SENT",
    /** An email notification for pickup was sent */
    PICKUP_READY_EMAIL_SENT = "PICKUP_READY_EMAIL_SENT",
    /** Shipping tracking number was set */
    TRACKING_NUMBER_ADDED = "TRACKING_NUMBER_ADDED",
    /** Shipping tracking number was edited */
    TRACKING_NUMBER_EDITED = "TRACKING_NUMBER_EDITED",
    /** Shipping tracking link was set */
    TRACKING_LINK_WAS_SET = "TRACKING_LINK_WAS_SET",
    /** An email confirmation of order shipment was sent */
    SHIPPING_CONFIRMATION_EMAIL_SENT = "SHIPPING_CONFIRMATION_EMAIL_SENT",
    /** Invoice was set in the order */
    INVOICE_WAS_SET = "INVOICE_WAS_SET",
    /** Invoice was removed from the order */
    INVOICE_WAS_REMOVED = "INVOICE_WAS_REMOVED",
    /** Invoice was sent to customer via email */
    INVOICE_WAS_SENT = "INVOICE_WAS_SENT",
    /** Email was sent to fulfiller */
    FULFILLER_EMAIL_SENT = "FULFILLER_EMAIL_SENT",
    /** Shipping address was updated */
    SHIPPING_ADDRESS_EDITED = "SHIPPING_ADDRESS_EDITED",
    /** Order email was updated */
    EMAIL_EDITED = "EMAIL_EDITED",
    /** Order partially paid. During the checkout for orders with deposit items. */
    ORDER_PARTIALLY_PAID = "ORDER_PARTIALLY_PAID"
}
export interface V2InvoiceInfo {
    /** Invoice ID */
    _id?: string;
    /** Invoice source */
    source?: InvoiceSource;
}
export declare enum InvoiceSource {
    /** Invoice source can't be classified, due to an error */
    UNSPECIFIED_INVOICE_SOURCE = "UNSPECIFIED_INVOICE_SOURCE",
    /** Invoice created using the Invoices API */
    WIX = "WIX"
}
export interface Fulfillment {
    /**
     * Fulfillment ID (auto generated upon fulfillment creation).
     * @readonly
     */
    _id?: string | null;
    /**
     * Fulfillment creation date and time.
     * @readonly
     */
    dateCreated?: Date | null;
    /** Information about the line items in the fulfilled order. */
    lineItems?: FulfillmentLineItem[];
    /** Tracking information. */
    trackingInfo?: FulfillmentTrackingInfo;
}
export interface FulfillmentLineItem {
    /** Line item ID (mirrors the line item index of the order). */
    index?: number;
    /**
     * Line item quantity.
     * On creation, if this parameter isn't passed, the new fulfillment will automatically include all items of this line item that have not already been linked to a fulfillment.
     * If the order does not have the requested quantity of line items available to add to this fulfillment, the fulfillment will not be created and an error will be returned.
     * This property will always have a value when returned.
     */
    quantity?: number | null;
}
export interface FulfillmentTrackingInfo {
    /** Tracking number. */
    trackingNumber?: string;
    /**
     * Shipping provider. Using the following shipping providers will allow for autofilling the tracking link:
     * * `fedex`
     * * `ups`
     * * `usps`
     * * `dhl`
     * * `canadaPost`
     */
    shippingProvider?: string;
    /** Tracking link - autofilled if using a predefined shipping provider, otherwise provided on creation. */
    trackingLink?: string | null;
}
export interface Discount {
    /**
     * Deprecated (use Totals.discount instead)
     * @readonly
     * @deprecated
     */
    value?: string;
    /** Applied coupon */
    appliedCoupon?: AppliedCoupon;
}
export interface AppliedCoupon {
    /** Coupon ID */
    couponId?: string;
    /** Coupon name */
    name?: string;
    /** Coupon code */
    code?: string;
}
/** Custom field */
export interface CustomField {
    /** Free text that the customer entered in the custom field during the checkout process */
    value?: string;
    /** Title for the custom field */
    title?: string;
    /** The title translated according to the buyer language */
    translatedTitle?: string;
}
export interface ChannelInfo {
    /** Sales channel that submitted the order */
    type?: ChannelType;
    /** Reference to an order ID from an external system, as defined in channelInfo (e.g., eBay or Amazon) */
    externalOrderId?: string | null;
    /** URL to the order in the external system, as defined in channelInfo (e.g., eBay or Amazon) */
    externalOrderUrl?: string | null;
}
export declare enum ChannelType {
    UNSPECIFIED = "UNSPECIFIED",
    WEB = "WEB",
    POS = "POS",
    EBAY = "EBAY",
    AMAZON = "AMAZON",
    OTHER_PLATFORM = "OTHER_PLATFORM",
    WIX_APP_STORE = "WIX_APP_STORE",
    WIX_INVOICES = "WIX_INVOICES",
    BACKOFFICE_MERCHANT = "BACKOFFICE_MERCHANT",
    WISH = "WISH",
    CLASS_PASS = "CLASS_PASS",
    GLOBAL_E = "GLOBAL_E",
    FACEBOOK = "FACEBOOK",
    ETSY = "ETSY",
    TIKTOK = "TIKTOK",
    FAIRE_COM = "FAIRE_COM"
}
export interface EnteredBy {
    _id?: string;
    identityType?: EnteredByIdentityType;
}
export declare enum EnteredByIdentityType {
    USER = "USER",
    MEMBER = "MEMBER",
    CONTACT = "CONTACT",
    APP = "APP"
}
export interface SubscriptionInfo {
    /** Subscription ID. */
    _id?: string | null;
    /** Current cycle number. For example, if the subscription is in the 3rd month of a 4-month subscription, the value will be `3`. */
    cycleNumber?: number;
    /** Subscription settings. */
    subscriptionSettings?: SubscriptionSettings;
    /** Subscription options info. */
    subscriptionOptionInfo?: SubscriptionOptionInfo;
}
export interface SubscriptionSettings {
    /** Frequency of recurring payment. */
    frequency?: SubscriptionFrequency;
    /** Whether subscription is renewed automatically at the end of each period. */
    autoRenewal?: boolean;
    /** Number of billing cycles before subscription ends. Ignored if `autoRenewal: true`. */
    billingCycles?: number | null;
}
/** Frequency unit of recurring payment */
export declare enum SubscriptionFrequency {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
export interface SubscriptionOptionInfo {
    /** Subscription option title. */
    title?: string;
    /** Subscription option description. */
    description?: string | null;
}
export interface V2Refund {
    /** Refund created timestamp. */
    dateCreated?: Date | null;
    /** Refund amount. */
    amount?: string;
    /** Reason for refund, given by user (optional). */
    reason?: string | null;
    /** Payment provider transaction ID. Used to find refund transaction info on the payment provider's side. */
    paymentProviderTransactionId?: string | null;
    /** Refund ID. */
    _id?: string;
    /** Whether refund was made externally (on the payment provider's side). */
    externalRefund?: boolean;
}
export interface GiftCard {
    transactionId?: string;
    /**
     * giftcard internal ID
     * @deprecated giftcard internal ID
     * @targetRemovalDate 2024-12-31
     */
    _id?: string;
    /** giftcard provider appid */
    providerId?: string;
    /** giftcard amount */
    amount?: string;
}
/** Triggered when a payment is updated. */
export interface PaymentsUpdated {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
    /** List of IDs of the updated payments. */
    paymentIds?: string[];
    /** List of IDs of the updated refunds. */
    refundIds?: string[];
}
/** Triggered when a refund is created. */
export interface RefundCreated {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
    /** ID of the created refund. */
    refundId?: string;
    /** Inventory restock details as part of this refund.. */
    restockInfo?: RestockInfo;
    /** Whether to send a refund confirmation email to the customer. */
    sendOrderRefundedEmail?: boolean;
    /** Custom message added to the refund confirmation email. */
    customMessage?: string | null;
    /** Refunded line items and quantities that are part of the created refund. */
    refundItems?: RefundItem[];
}
export interface RestockInfo {
    /** Restock type. */
    type?: RestockType;
    /** Restocked line items and quantities. Only relevant for `{"type": "SOME_ITEMS"}`. */
    items?: RestockItem[];
}
export declare enum RestockType {
    NO_ITEMS = "NO_ITEMS",
    ALL_ITEMS = "ALL_ITEMS",
    SOME_ITEMS = "SOME_ITEMS"
}
export interface RestockItem {
    /** ID of the line item being restocked. */
    lineItemId?: string;
    /** Line item quantity being restocked. */
    quantity?: number;
}
export interface RefundCompleted {
    /** Order ID. */
    orderId?: string;
    /** Completed refund. */
    refund?: Refund;
    /** Refund side effects. */
    sideEffects?: RefundSideEffects;
    /** Order transactions after refund is completed. */
    orderTransactions?: OrderTransactions;
}
export interface RefundSideEffects {
    /** Inventory restock details as part of this refund. */
    restockInfo?: RestockInfo;
    /** Whether to send a refund confirmation email to the customer. */
    sendOrderRefundedEmail?: boolean;
    /** Custom message added to the refund confirmation email. */
    customMessage?: string | null;
}
export interface ListTransactionsForSingleOrderRequest {
    /** Order ID. */
    orderId: string;
}
export interface ListTransactionsForSingleOrderResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
}
export interface ListTransactionsForMultipleOrdersRequest {
    /** Order IDs for which to retrieve transactions. */
    orderIds: string[];
}
export interface ListTransactionsForMultipleOrdersResponse {
    /** List of order IDs and their associated transactions. */
    orderTransactions?: OrderTransactions[];
}
export interface AddPaymentsRequest {
    /** Order ID. */
    orderId: string;
    /** Payments to be added to order. */
    payments: Payment[];
}
export interface AddPaymentsResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
    /** IDs of added order payments. */
    paymentsIds?: string[];
}
export interface AddRefundRequest {
    /** Order ID this refunds related to */
    orderId?: string;
    /** Refund with refund transactions to be added to order. */
    refund?: Refund;
    /** Side effect details related to refund */
    sideEffects?: RefundSideEffects;
}
export interface AddRefundResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
    /** Created refund ID */
    refundId?: string;
}
export interface UpdatePaymentStatusRequest {
    /** Order ID. */
    orderId: string;
    /** Payment ID. */
    paymentId: string;
    /** Payment status. */
    status?: TransactionStatus;
}
export interface UpdatePaymentStatusResponse {
    /** Order ID and its associated transactions after update. */
    orderTransactions?: OrderTransactions;
}
export interface BulkUpdatePaymentStatusesRequest {
    /** Order and payment IDs for which to update payment status. */
    paymentAndOrderIds: PaymentAndOrderId[];
    /** Whether to return the full payment entity (`results.item`) in the response. */
    returnFullEntity?: boolean;
    /** Payment status. */
    status?: TransactionStatus;
}
export interface PaymentAndOrderId {
    /** Order ID. */
    orderId?: string;
    /**
     * Payment ID.
     * todo: remove comment once UI will use BulkMarkOrderAsPaid
     */
    paymentId?: string;
}
export interface BulkUpdatePaymentStatusesResponse {
    /** Bulk operation results. */
    results?: BulkPaymentResult[];
    /** Bulk operation metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkPaymentResult {
    /** Item metadata. */
    itemMetadata?: ItemMetadata;
    /** Updated payment. Returned if `return_full_entity` set to `true`. */
    item?: Payment;
}
export interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
export interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
export interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
export interface UpdateRefundRequest {
    /** Order ID. */
    orderId?: string;
    /** Refund with updated field values. */
    refund?: Refund;
}
export interface UpdateRefundResponse {
    /** Refund after update. */
    refund?: Refund;
    /** Order transactions after update. */
    orderTransactions?: OrderTransactions;
}
export interface UpdateRefundTransactionRequest {
}
export interface UpdateRefundTransactionResponse {
}
export interface UpdatePaymentsRequest {
}
export interface MaskedPayment {
}
export interface UpdatePaymentsResponse {
}
export interface QueryOrderTransactionsRequest {
}
export interface CursorQuery extends CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
}
/** @oneof */
export interface CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
export declare enum SortOrder {
    /** Ascending order. */
    ASC = "ASC",
    /** Descending order. */
    DESC = "DESC"
}
export interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
export interface QueryOrderTransactionsResponse {
}
export interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
export interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
export interface TriggerRefundRequest {
    /** The order this refund related to */
    orderId?: string;
    /**
     * Refund operations information
     * Currently, only *one* payment refund is supported per request
     */
    payments?: PaymentRefund[];
    /** Business model of a refund */
    details?: RefundDetails;
    /** How to restock items as part of this refund */
    restockInfo?: RestockInfo;
    /** Should send a confirmation mail to the customer */
    sendOrderRefundedEmail?: boolean;
    /** Personal note added to the email */
    customMessage?: string | null;
}
export interface PaymentRefund {
    /** Specific payment within the order to refund */
    paymentId?: string;
    /** Refund amount. Not relevant for membership and gift card refunds. */
    amount?: Price;
    /**
     * Whether refund is made externally and manually (on the payment provider's side)
     * When false (default), the payment gateway will be called in order to make an actual refund, and then the payment will be marked as refunded.
     * When true, the payment will only be *marked* as refunded, and no actual refund will be performed.
     */
    externalRefund?: boolean;
}
export interface TriggerRefundResponse {
    /** All order's transactions after the refunds were added */
    orderTransactions?: OrderTransactions;
    /** Created refund ID */
    refundId?: string;
}
export interface CalculateRefundRequest {
    /** Order ID */
    orderId?: string;
    /** Refunded line items and quantity */
    refundItems?: CalculateRefundItemRequest[];
    /** Should include shipping in refund calculation */
    refundShipping?: boolean;
}
export interface CalculateRefundItemRequest {
    /** ID of the line item being refunded */
    lineItemId?: string;
    /** How much of that line item is being refunded */
    quantity?: number;
    /** Should this item be restocked (used for validation purposes) */
    restock?: boolean;
}
export interface CalculateRefundResponse {
    /** Total refundable amount */
    total?: string;
    /** Tax cost of the order */
    tax?: string;
    /** Discount given for this order */
    discount?: string;
    /** Total cost of the order (without tax) */
    subtotal?: string;
    /** Previous refund given on that order */
    previouslyRefundedAmount?: string | null;
    /** The refundable items of that order */
    items?: CalculateRefundItemResponse[];
}
export interface CalculateRefundItemResponse {
    /** Line item ID */
    lineItemId?: string;
    /** The line item's price */
    lineItemPrice?: number;
}
export interface GetRefundabilityStatusRequest {
    /** Order ID. */
    orderId?: string;
}
export interface GetRefundabilityStatusResponse {
    /** Refundability details. */
    refundabilities?: Refundability[];
    /** Whether the order supports refunding per item. */
    refundablePerItem?: boolean;
}
export interface Refundability extends RefundabilityAdditionalRefundabilityInfoOneOf {
    /** Reason why payment is not refundable. */
    nonRefundableReason?: NonRefundableReason;
    /** Reason why payment is only refundable manually. */
    manuallyRefundableReason?: ManuallyRefundableReason;
    /** Payment ID. */
    paymentId?: string;
    /** Payment refundability status. */
    refundabilityStatus?: RefundableStatus;
    /** Link to payment provider dashboard. */
    providerLink?: string | null;
}
/** @oneof */
export interface RefundabilityAdditionalRefundabilityInfoOneOf {
    /** Reason why payment is not refundable. */
    nonRefundableReason?: NonRefundableReason;
    /** Reason why payment is only refundable manually. */
    manuallyRefundableReason?: ManuallyRefundableReason;
}
export declare enum RefundableStatus {
    /** Not refundable. */
    NOT_REFUNDABLE = "NOT_REFUNDABLE",
    /** Refundable manually. */
    MANUAL = "MANUAL",
    /** Refundable. */
    REFUNDABLE = "REFUNDABLE"
}
export declare enum NonRefundableReason {
    /** No reason. */
    NONE = "NONE",
    /** Payment already refunded. */
    ALREADY_REFUNDED = "ALREADY_REFUNDED",
    /** Payment provider is down. */
    PROVIDER_IS_DOWN = "PROVIDER_IS_DOWN",
    /** Internal error occurred. */
    INTERNAL_ERROR = "INTERNAL_ERROR",
    /** Payment not made. */
    NOT_PAID = "NOT_PAID",
    /** Access denied. */
    ACCESS_DENIED = "ACCESS_DENIED",
    /** Payment amount is zero. */
    ZERO_PRICE = "ZERO_PRICE",
    /** Disabled by provider. */
    DISABLED_BY_PROVIDER = "DISABLED_BY_PROVIDER",
    /** Payment partially paid. */
    PARTIALLY_PAID = "PARTIALLY_PAID",
    /** Deposit for online item. */
    DEPOSIT_ONLINE_ITEM = "DEPOSIT_ONLINE_ITEM",
    /** Refund is pending. */
    PENDING_REFUND = "PENDING_REFUND",
    /** Action forbidden. */
    FORBIDDEN = "FORBIDDEN"
}
export declare enum ManuallyRefundableReason {
    /** Payment expired. */
    EXPIRED = "EXPIRED",
    /** Payment method not supported. */
    NOT_SUPPORTED = "NOT_SUPPORTED",
    /** Payment not found. */
    NOT_FOUND = "NOT_FOUND",
    /** Payment made offline. */
    OFFLINE = "OFFLINE",
    /** Refund requires interaction with card reader. */
    REQUIRES_CARD_READER = "REQUIRES_CARD_READER"
}
export interface ListInvoicesForSingleOrderRequest {
    /** Order ID. */
    orderId?: string;
}
export interface ListInvoicesForSingleOrderResponse {
    /** List of invoices. */
    invoices?: InvoiceInfo[];
}
export interface InvoiceInfo {
    /** Invoice ID. */
    _id?: string;
    /** ID of the app that set the invoice. */
    appId?: string;
    /**
     * Invoice URL.
     * @deprecated
     */
    url?: string | null;
    /**
     * Invoice creation date and time.
     * @deprecated
     */
    _createdDate?: Date | null;
}
export interface ListInvoicesForMultipleOrdersRequest {
    /** Order IDs for which to retrieve invoices. */
    orderIds?: string[];
}
export interface ListInvoicesForMultipleOrdersResponse {
    /** List of order IDs and their associated invoices. */
    invoicesForOrder?: InvoicesForOrder[];
}
export interface InvoicesForOrder {
    /** Order ID. */
    orderId?: string;
    /** Invoices info. */
    invoicesInfo?: InvoiceInfo[];
}
export interface GenerateInvoiceRequest {
    /** Order ID. */
    orderId?: string;
}
export interface GenerateInvoiceResponse {
    /** Invoice ID. */
    invoiceId?: string;
}
export interface BulkGenerateInvoicesRequest {
    /** Order IDs. */
    orderIds?: string[];
}
export interface BulkGenerateInvoicesResponse {
    results?: BulkInvoiceResult[];
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkInvoiceResult {
    itemMetadata?: ItemMetadata;
    item?: InvoiceForOrder;
}
export interface InvoiceForOrder {
    /** Order ID. */
    orderId?: string;
    /** Invoice ID. */
    invoiceId?: string;
}
export interface AddInvoiceToOrderRequest {
    /** Order ID. */
    orderId?: string;
    /** Invoice info. */
    invoiceInfo?: InvoiceInfo;
}
export interface AddInvoiceToOrderResponse {
    /** List of order invoices. */
    orderInvoices?: InvoiceInfo[];
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entity?: string;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
export interface ActionEvent {
    body?: string;
}
export interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface PriceNonNullableFields {
    amount: string;
    formattedAmount: string;
}
interface AuthorizationActionFailureDetailsNonNullableFields {
    failureCode: string;
}
interface AuthorizationCaptureNonNullableFields {
    status: AuthorizationCaptureStatus;
    amount?: PriceNonNullableFields;
    failureDetails?: AuthorizationActionFailureDetailsNonNullableFields;
}
interface AuthorizationVoidNonNullableFields {
    status: AuthorizationVoidStatus;
    failureDetails?: AuthorizationActionFailureDetailsNonNullableFields;
    reason: Reason;
}
interface ScheduledActionNonNullableFields {
    actionType: ActionType;
}
interface AuthorizationDetailsNonNullableFields {
    delayedCapture: boolean;
    captures: AuthorizationCaptureNonNullableFields[];
    void?: AuthorizationVoidNonNullableFields;
    scheduledAction?: ScheduledActionNonNullableFields;
}
interface RegularPaymentDetailsNonNullableFields {
    offlinePayment: boolean;
    status: TransactionStatus;
    savedPaymentMethod: boolean;
    authorizationDetails?: AuthorizationDetailsNonNullableFields;
}
interface GiftCardPaymentDetailsNonNullableFields {
    giftCardPaymentId: string;
    giftCardId: string;
    appId: string;
    voided: boolean;
}
interface MembershipNameNonNullableFields {
    original: string;
}
interface MembershipPaymentDetailsNonNullableFields {
    membershipId: string;
    lineItemId: string;
    status: MembershipPaymentStatus;
    name?: MembershipNameNonNullableFields;
    voided: boolean;
    providerAppId: string;
}
interface WixReceiptInfoNonNullableFields {
    receiptId: string;
}
interface PaymentNonNullableFields {
    regularPaymentDetails?: RegularPaymentDetailsNonNullableFields;
    giftcardPaymentDetails?: GiftCardPaymentDetailsNonNullableFields;
    membershipPaymentDetails?: MembershipPaymentDetailsNonNullableFields;
    wixReceipt?: WixReceiptInfoNonNullableFields;
    amount?: PriceNonNullableFields;
    refundDisabled: boolean;
    supportReceiptGeneration: boolean;
}
interface RefundTransactionNonNullableFields {
    paymentId: string;
    amount?: PriceNonNullableFields;
    refundStatus: RefundStatus;
    externalRefund: boolean;
}
interface RefundItemNonNullableFields {
    lineItemId: string;
    quantity: number;
}
interface LineItemRefundNonNullableFields {
    lineItemId: string;
    quantity: number;
}
interface AdditionalFeeRefundNonNullableFields {
    additionalFeeId: string;
    amount?: PriceNonNullableFields;
}
interface ShippingRefundNonNullableFields {
    amount?: PriceNonNullableFields;
}
interface RefundDetailsNonNullableFields {
    items: RefundItemNonNullableFields[];
    shippingIncluded: boolean;
    lineItems: LineItemRefundNonNullableFields[];
    additionalFees: AdditionalFeeRefundNonNullableFields[];
    shipping?: ShippingRefundNonNullableFields;
}
interface AggregatedRefundSummaryNonNullableFields {
    requestedRefund?: PriceNonNullableFields;
    pendingRefund?: PriceNonNullableFields;
    refunded?: PriceNonNullableFields;
    failedRefundAmount?: PriceNonNullableFields;
    pending: boolean;
}
interface RefundNonNullableFields {
    _id: string;
    transactions: RefundTransactionNonNullableFields[];
    details?: RefundDetailsNonNullableFields;
    summary?: AggregatedRefundSummaryNonNullableFields;
}
interface OrderTransactionsNonNullableFields {
    orderId: string;
    payments: PaymentNonNullableFields[];
    refunds: RefundNonNullableFields[];
}
export interface ListTransactionsForSingleOrderResponseNonNullableFields {
    orderTransactions?: OrderTransactionsNonNullableFields;
}
export interface ListTransactionsForMultipleOrdersResponseNonNullableFields {
    orderTransactions: OrderTransactionsNonNullableFields[];
}
export interface AddPaymentsResponseNonNullableFields {
    orderTransactions?: OrderTransactionsNonNullableFields;
    paymentsIds: string[];
}
export interface UpdatePaymentStatusResponseNonNullableFields {
    orderTransactions?: OrderTransactionsNonNullableFields;
}
interface ApplicationErrorNonNullableFields {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields;
}
interface BulkPaymentResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
    item?: PaymentNonNullableFields;
}
interface BulkActionMetadataNonNullableFields {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
export interface BulkUpdatePaymentStatusesResponseNonNullableFields {
    results: BulkPaymentResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
/**
 * Retrieves information about payments and refunds associated with a specified order.
 *
 *
 * The `listTransactionsForSingleOrder()` function returns a Promise that resolves when the specified order's transaction records are retrieved.
 * @param orderId - Order ID.
 * @public
 * @requiredField orderId
 * @permissionId ECOM.READ_TRANSACTIONS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.ListTransactionsForSingleOrder
 */
export declare function listTransactionsForSingleOrder(orderId: string): Promise<ListTransactionsForSingleOrderResponse & ListTransactionsForSingleOrderResponseNonNullableFields>;
/**
 * Retrieves information about payments and refunds associated with all specified orders.
 *
 *
 * The `listTransactionsForMultipleOrders()` function returns a Promise that resolves when the specified orders' transaction records are retrieved.
 * @param orderIds - Order IDs for which to retrieve transactions.
 * @public
 * @requiredField orderIds
 * @permissionId ECOM.READ_TRANSACTIONS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.ListTransactionsForMultipleOrders
 */
export declare function listTransactionsForMultipleOrders(orderIds: string[]): Promise<ListTransactionsForMultipleOrdersResponse & ListTransactionsForMultipleOrdersResponseNonNullableFields>;
/**
 * Adds up to 50 payment records to an order.
 *
 *
 * The `addPayments()` function returns a Promise that resolves when the payment records are added to an order.
 *
 * > **Note:** This does **NOT** perform the actual charging - the order is only updated with records of the payments.
 * @param orderId - Order ID.
 * @param payments - Payments to be added to order.
 * @public
 * @requiredField orderId
 * @requiredField payments
 * @requiredField payments.amount
 * @requiredField payments.giftcardPaymentDetails.giftCardPaymentId
 * @permissionId ECOM.MODIFY_TRANSACTIONS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.AddPayments
 */
export declare function addPayments(orderId: string, payments: Payment[]): Promise<AddPaymentsResponse & AddPaymentsResponseNonNullableFields>;
/**
 * Updates the status of an order's payment.
 *
 *
 * The `updatePaymentStatus()` function returns a Promise that resolves when the payment status is updated.
 * @public
 * @requiredField identifiers
 * @requiredField identifiers.orderId
 * @requiredField identifiers.paymentId
 * @permissionId ECOM.MODIFY_TRANSACTIONS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.UpdatePaymentStatus
 */
export declare function updatePaymentStatus(identifiers: UpdatePaymentStatusIdentifiers, options?: UpdatePaymentStatusOptions): Promise<UpdatePaymentStatusResponse & UpdatePaymentStatusResponseNonNullableFields>;
export interface UpdatePaymentStatusIdentifiers {
    /** Payment ID. */
    paymentId: string;
    /** Order ID. */
    orderId: string;
}
export interface UpdatePaymentStatusOptions {
    /** Payment status. */
    status?: TransactionStatus;
}
/**
 * Updates multiple order payments with a specified status.
 *
 *
 * The `bulkUpdatePaymentStatus()` function returns a Promise that resolves when the payment statuses are updated.
 * @param paymentAndOrderIds - Order and payment IDs for which to update payment status.
 * @public
 * @requiredField paymentAndOrderIds
 * @permissionId ECOM.MODIFY_TRANSACTIONS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.payments.v1.Payments.BulkUpdatePaymentStatuses
 */
export declare function bulkUpdatePaymentStatuses(paymentAndOrderIds: PaymentAndOrderId[], options?: BulkUpdatePaymentStatusesOptions): Promise<BulkUpdatePaymentStatusesResponse & BulkUpdatePaymentStatusesResponseNonNullableFields>;
export interface BulkUpdatePaymentStatusesOptions {
    /** Whether to return the full payment entity (`results.item`) in the response. */
    returnFullEntity?: boolean;
    /** Payment status. */
    status?: TransactionStatus;
}
export {};
