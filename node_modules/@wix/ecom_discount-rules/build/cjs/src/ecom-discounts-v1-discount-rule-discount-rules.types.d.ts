export interface DiscountRule {
    /**
     * Discount rule ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the discount rule is updated.
     * To prevent conflicting changes, the current `revision` must be passed when updating the discount rule.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the discount rule was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the discount rule was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Whether the discount rule is active.
     *
     * Default: `true`
     */
    active?: boolean | null;
    /** Discount rule name. */
    name?: string | null;
    /**
     * Discount rule trigger.
     * A set of conditions that must be met for the `discounts` to be applied.
     * Not passing a trigger will cause the discount to always apply.
     */
    trigger?: DiscountTrigger;
    /** Time frame in which the discount rule is active. */
    activeTimeInfo?: ActiveTimeInfo;
    /**
     * List of discounts that are applied when one or more triggers are met.
     *
     * > **Notes:**
     * >
     * > + Currently, only 1 discount can be defined per discount rule.
     * > + A discount rule can be applied on multiple items per cart.
     * > + A discount rule can only be applied once per item.
     */
    discounts?: Discounts;
    /**
     * Discount rule status.
     * Default: `UNDEFINED`
     * @readonly
     */
    status?: Status;
    /**
     * Number of times the discount rule was used.
     * @readonly
     */
    usageCount?: number;
}
/** DiscountTrigger - description of a set of conditions, that if met, will trigger the associated rule actions */
export interface DiscountTrigger extends DiscountTriggerTriggerOneOf {
    /** Chain multiple triggers with the `and` operator. */
    and?: And;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or;
    /** Custom trigger. */
    customTrigger?: Custom;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange;
    /** Trigger type. */
    triggerType?: TriggerType;
}
/** @oneof */
export interface DiscountTriggerTriggerOneOf {
    /** Chain multiple triggers with the `and` operator. */
    and?: And;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or;
    /** Custom trigger. */
    customTrigger?: Custom;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange;
}
/**
 * This object represents a scope of catalog items. Examples:
 * 1. All catalog items of a specific app - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id`
 * 2. Specific catalog item - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id` + `catalog_item_ids`
 * 3. External catalog filter - type = CUSTOM_FILTER, CustomFilter with 'app_id' + 'params'
 */
export interface Scope extends ScopeScopeItemsOneOf {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter;
    /** Scope ID. */
    id?: string;
    /** Scope type. */
    type?: ScopeType;
}
/** @oneof */
export interface ScopeScopeItemsOneOf {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter;
}
export declare enum ScopeType {
    UNDEFINED_SCOPE = "UNDEFINED_SCOPE",
    /** Specific catalog items */
    CATALOG_ITEM = "CATALOG_ITEM",
    /** Specific items by custom filters */
    CUSTOM_FILTER = "CUSTOM_FILTER"
}
export interface CatalogItemFilter {
    /** Catalog App ID. For example, the Wix Stores, Wix Bookings, or 3rd-party `appId`. */
    catalogAppId?: string;
    /** ID of the item within its Wix or 3rd-party catalog. For example, `productId` for Wix Stores. */
    catalogItemIds?: string[];
}
export interface CustomFilter {
    /** Custom filter app ID, when relevant. */
    appId?: string;
    /**
     * Custom filter in `{ "key": "value" }` form.
     * For example, an array of `collectionIDs`:
     * `{ ["collectionId": "12345"], ["collectionId": "67890"] }`.
     */
    params?: Record<string, any> | null;
}
export interface And {
    /** List of triggers to have an "AND" operator between their results. */
    triggers?: DiscountTrigger[];
}
export interface Or {
    /** List of triggers to have an "OR" operator between their results. */
    triggers?: DiscountTrigger[];
}
export interface Custom {
    /** Trigger ID. */
    id?: string;
    /** ID of the app that created the trigger. */
    appId?: string;
}
export interface SubtotalRange {
    /** Relevant scopes for `SPECIFIC_ITEMS` target type. */
    scopes?: Scope[];
    /** Minimum subtotal price (inclusive). */
    from?: string | null;
    /** Maximum subtotal price (inclusive). */
    to?: string | null;
}
export interface ItemQuantityRange {
    /** Relevant scopes for `SPECIFIC_ITEMS` target type. */
    scopes?: Scope[];
    /** Minimum item quantity (inclusive). */
    from?: number | null;
    /** Maximum item quantity (inclusive). */
    to?: number | null;
}
export declare enum TriggerType {
    UNDEFINED = "UNDEFINED",
    /** Operator used for chaining multiple triggers. Currently 1 `AND` chain operator is supported. */
    AND = "AND",
    /** Subtotal must be within the specified `subtotalRange` values. */
    SUBTOTAL_RANGE = "SUBTOTAL_RANGE",
    /** Quantity of items in scope must be within specified `itemQuantityRange` values. */
    ITEM_QUANTITY_RANGE = "ITEM_QUANTITY_RANGE",
    /** Custom trigger type defined in `customTrigger` object. */
    CUSTOM = "CUSTOM",
    /** Chain multiple triggers with OR operator */
    OR = "OR"
}
export interface ActiveTimeInfo {
    /** Date and time the discount rule is active **from**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    start?: Date | null;
    /** Date and time the discount rule is active **till**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    end?: Date | null;
}
export interface Discounts {
    /** Discounts. */
    values?: Discount[];
}
export interface Discount extends DiscountDiscountOneOf {
    /** Percentage to discount from original price. */
    percentage?: number;
    /** Amount to discount from original price. */
    fixedAmount?: string;
    /** Fixed price. Line item will be fixed to this price. */
    fixedPrice?: string;
    /**
     * Discount target.
     *
     * + `SPECIFIC_ITEMS`: Discount applies to a specific set of items.
     */
    targetType?: Type;
    /** Data related to `SPECIFIC_ITEMS` target type. */
    specificItemsInfo?: SpecificItemsInfo;
    /** Discount type. */
    discountType?: DiscountType;
}
/** @oneof */
export interface DiscountDiscountOneOf {
    /** Percentage to discount from original price. */
    percentage?: number;
    /** Amount to discount from original price. */
    fixedAmount?: string;
    /** Fixed price. Line item will be fixed to this price. */
    fixedPrice?: string;
}
export declare enum Type {
    /** Target type is not defined */
    UNDEFINED = "UNDEFINED",
    /** Target type is a set of specific items */
    SPECIFIC_ITEMS = "SPECIFIC_ITEMS"
}
export interface SpecificItemsInfo {
    /** All associated scopes for `SPECIFIC_ITEMS` target type. */
    scopes?: Scope[];
}
export declare enum DiscountType {
    UNDEFINED = "UNDEFINED",
    /** Price is reduced by percentage value. */
    PERCENTAGE = "PERCENTAGE",
    /** Price is reduced by fixed amount. */
    FIXED_AMOUNT = "FIXED_AMOUNT",
    /** Price will be set to fixed amount. */
    FIXED_PRICE = "FIXED_PRICE"
}
export interface BuyXGetYInfo {
    /** Information about which items must be in the cart (buy X) for the discount to apply (get Y). */
    customerBuys?: CustomerBuy;
    /** Information about which items will be discounted (get Y). */
    customerGets?: CustomerGet;
    /**
     * The maximum number of times the 'buy X get Y' discount can be applied.
     * For example, when the value of `limit` is `2`, with a "2+1" sale on all items, the following logic applies:
     * + Buy 2 get 1, buy 3 get 1.
     * + Buy 4 get 2, buy 6 get 2, buy 9 get 2, and so on.
     */
    limit?: number | null;
}
export interface CustomerBuy extends CustomerBuyConditionOneOf {
    /** Minimum number of items the customer must add to the cart to be eligible for a discount. */
    minimumQuantity?: number;
    /** Minimum price the customer must add to the cart to be eligible for a discount. */
    minimumSpend?: string | null;
    /** Scopes of the items that must be added to the cart to enable the discount. */
    scopes?: Scope[];
}
/** @oneof */
export interface CustomerBuyConditionOneOf {
    /** Minimum number of items the customer must add to the cart to be eligible for a discount. */
    minimumQuantity?: number;
    /** Minimum price the customer must add to the cart to be eligible for a discount. */
    minimumSpend?: string | null;
}
export interface CustomerGet {
    /**
     * Exact number of items in the cart that will be discounted.
     * If the cart contains fewer items than the value of quantity, the discount will not apply.
     */
    quantity?: number;
    /** Scopes of the items that will be discounted. */
    scopes?: Scope[];
}
export declare enum Status {
    /** Rule status is not defined. */
    UNDEFINED = "UNDEFINED",
    /** Rule status is live. */
    LIVE = "LIVE",
    /** Rule status is expired, it might have been live in the past. */
    EXPIRED = "EXPIRED",
    /** Rule status is pending, it might be live in the future. */
    PENDING = "PENDING"
}
/** The discount settings */
export interface DiscountSettings {
    /** Discount applies to either `ALL_ITEMS`, or to the `LOWEST_PRICED_ITEM`. */
    appliesTo?: AppliedSubjectType;
    /**
     * Whether the discount will apply to subscriptions.
     *
     * Default: `false`
     */
    includeSubscription?: boolean | null;
    /** Maximum total number of uses allowed for the discount rule. */
    usageLimit?: number | null;
    /**
     * The usage limit per user per discount.
     * When not provided, this setting will not apply.
     */
    usageLimitPerUser?: number | null;
}
/** TODO: check if can be removed */
export declare enum AppliedSubjectType {
    UNDEFINED = "UNDEFINED",
    /** Discount applies to all items at checkout. */
    ALL_ITEMS = "ALL_ITEMS",
    /** Discount applies to the lowest priced item at checkout. */
    LOWEST_PRICED_ITEM = "LOWEST_PRICED_ITEM"
}
export interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
export interface CreateDiscountRuleRequest {
    /** Discount rule info. */
    discountRule: DiscountRule;
}
export interface CreateDiscountRuleResponse {
    /** Discount rule. */
    discountRule?: DiscountRule;
}
export interface GetDiscountRuleRequest {
    /** ID of the discount rule to retrieve. */
    discountRuleId: string;
}
export interface GetDiscountRuleResponse {
    /** The requested discount rule. */
    discountRule?: DiscountRule;
}
export interface UpdateDiscountRuleRequest {
    /** Discount rule info. */
    discountRule: DiscountRule;
}
export interface UpdateDiscountRuleResponse {
    /** Updated discount rule. */
    discountRule?: DiscountRule;
}
export interface DeleteDiscountRuleRequest {
    /** ID of the discount rule to delete. */
    discountRuleId: string;
}
export interface DeleteDiscountRuleResponse {
}
export interface QueryDiscountRulesRequest {
    /** Query options. */
    query?: PlatformQuery;
}
export interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting[];
}
/** @oneof */
export interface PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
export interface PlatformPaging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
export interface QueryDiscountRulesResponse {
    /** List of discount rules. */
    discountRules?: DiscountRule[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PlatformPagingMetadata;
}
export interface PlatformPagingMetadata {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors;
}
export interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
export interface GetAppliedDiscountsRequest {
    /** Line items for which to check for discount rules. */
    lineItems?: LineItem[];
    /** Persistent ID that correlates between the various eCommerce elements: cart, checkout, and order. */
    purchaseFlowId?: string | null;
}
export interface LineItem {
    /** Line item ID. */
    id?: string;
    /** Line item quantity. */
    quantity?: number | null;
    /** Catalog and item reference info. Learn more about [integrating Wix Stores products with Wix eCommerce](https://dev.wix.com/api/rest/wix-stores/catalog/ecommerce-integration). */
    catalogReference?: CatalogReference;
    /** Line item price. */
    price?: string;
}
/** Used for grouping line items. Sent when an item is added to a cart, checkout, or order. */
export interface CatalogReference {
    /** ID of the item within the catalog it belongs to. */
    catalogItemId?: string;
    /**
     * ID of the app providing the catalog.
     *
     * You can get your app's ID from its page in the [app dashboard](https://dev.wix.com/dc3/my-apps/).
     *
     * For items from Wix catalogs, the following values always apply:
     * + Wix Stores: `"215238eb-22a5-4c36-9e7b-e7c08025e04e"`
     * + Wix Bookings: `"13d21c63-b5ec-5912-8397-c3a5ddb27a97"`
     * + Wix Restaurants: `"9a5d83fd-8570-482e-81ab-cfa88942ee60"`
     */
    appId?: string;
    /**
     * Additional item details in key:value pairs. Use this optional field to provide more specificity with item selection. The `options` field values differ depending on which catalog is providing the items.
     *
     * For products and variants from a Wix Stores catalog, learn more about [eCommerce integration](https://dev.wix.com/docs/rest/business-solutions/stores/catalog/e-commerce-integration).
     */
    options?: Record<string, any> | null;
}
export interface GetAppliedDiscountsResponse {
    /** All eligible discounts. */
    appliedDiscounts?: AppliedDiscount[];
}
export interface AppliedDiscount {
    /** Discount type. */
    discountType?: Type;
    /** IDs of line items the discount applies to, in GUID format. */
    lineItemIds?: string[];
    /** Applied discount rule. */
    appliedDiscountRule?: AppliedDiscountRule;
}
export interface AppliedDiscountRule {
    /** Applied discount rule ID. */
    id?: string;
    /** Discount rule name. */
    name?: DiscountRuleName;
    /** Total amount reduced from all discounted line items. */
    amount?: MultiCurrencyPrice;
    /** Discount rule type. */
    discountRuleType?: DiscountType;
}
export interface DiscountRuleName {
    /** Original discount rule name (in site's default language). */
    original?: string;
    /**
     * Translated discount rule name according to buyer language.
     *
     * Default: `original`
     */
    translated?: string | null;
}
export interface MultiCurrencyPrice {
    /** Amount. */
    amount?: string;
    /**
     * Converted amount.
     * @readonly
     */
    convertedAmount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
    /**
     * Converted amount formatted with currency symbol.
     * @readonly
     */
    formattedConvertedAmount?: string;
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntityAsJson?: string | null;
}
export interface ActionEvent {
    bodyAsJson?: string;
}
export interface Empty {
}
export interface DiscountRuleUsageLimitReached {
    /** Discount Rule */
    rule?: DiscountRule;
}
export interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface AndNonNullableFields {
    triggers: DiscountTriggerNonNullableFields[];
}
interface OrNonNullableFields {
    triggers: DiscountTriggerNonNullableFields[];
}
interface CustomNonNullableFields {
    id: string;
    appId: string;
}
interface CatalogItemFilterNonNullableFields {
    catalogAppId: string;
    catalogItemIds: string[];
}
interface CustomFilterNonNullableFields {
    appId: string;
}
interface ScopeNonNullableFields {
    catalogItemFilter?: CatalogItemFilterNonNullableFields;
    customFilter?: CustomFilterNonNullableFields;
    id: string;
    type: ScopeType;
}
interface SubtotalRangeNonNullableFields {
    scopes: ScopeNonNullableFields[];
}
interface ItemQuantityRangeNonNullableFields {
    scopes: ScopeNonNullableFields[];
}
interface DiscountTriggerNonNullableFields {
    and?: AndNonNullableFields;
    or?: OrNonNullableFields;
    customTrigger?: CustomNonNullableFields;
    subtotalRange?: SubtotalRangeNonNullableFields;
    itemQuantityRange?: ItemQuantityRangeNonNullableFields;
    triggerType: TriggerType;
}
interface SpecificItemsInfoNonNullableFields {
    scopes: ScopeNonNullableFields[];
}
interface CustomerBuyNonNullableFields {
    minimumQuantity: number;
    scopes: ScopeNonNullableFields[];
}
interface CustomerGetNonNullableFields {
    quantity: number;
    scopes: ScopeNonNullableFields[];
}
interface BuyXGetYInfoNonNullableFields {
    customerBuys?: CustomerBuyNonNullableFields;
    customerGets?: CustomerGetNonNullableFields;
}
interface DiscountNonNullableFields {
    percentage: number;
    fixedAmount: string;
    fixedPrice: string;
    targetType: Type;
    specificItemsInfo?: SpecificItemsInfoNonNullableFields;
    discountType: DiscountType;
    buyXGetYInfo?: BuyXGetYInfoNonNullableFields;
}
interface DiscountsNonNullableFields {
    values: DiscountNonNullableFields[];
}
interface DiscountSettingsNonNullableFields {
    appliesTo: AppliedSubjectType;
}
interface DiscountRuleNonNullableFields {
    trigger?: DiscountTriggerNonNullableFields;
    discounts?: DiscountsNonNullableFields;
    status: Status;
    usageCount: number;
    settings?: DiscountSettingsNonNullableFields;
}
export interface CreateDiscountRuleResponseNonNullableFields {
    discountRule?: DiscountRuleNonNullableFields;
}
export interface GetDiscountRuleResponseNonNullableFields {
    discountRule?: DiscountRuleNonNullableFields;
}
export interface UpdateDiscountRuleResponseNonNullableFields {
    discountRule?: DiscountRuleNonNullableFields;
}
export interface QueryDiscountRulesResponseNonNullableFields {
    discountRules: DiscountRuleNonNullableFields[];
}
export {};
